<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <!-- KaTeX -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
      integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0"
      crossorigin="anonymous"
    />

    <link rel="stylesheet" href="./assets/main.css" />

    <title>You already know how to parse infix operators</title>
  </head>

  <body>
    <main><h1>You already know how to parse infix operators</h1><p>Our final parser is only 60 lines long, yet is capable of parsing expressions
like</p><pre><code><span class="string">&#x27;(1 + 4)! * -3^2&#x27;</span></code></pre><div class="h2-container"><h2 id="Parsing a comma-separated list">Parsing a comma-separated list</h2><a href="#Parsing a comma-separated list">#</a></div><p>Our first step is to write a parser capable of turning a string like</p><pre><code><span class="string">&#x27;apples, bananas, oranges&#x27;</span></code></pre><p>into the array</p><pre><code><span class="punct">[</span><span class="string">&#x27;apples&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;bananas&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;oranges&#x27;</span><span class="punct">]</span></code></pre><p>Here&#x27;s a <a href="https://en.wikipedia.org/wiki/Context-free_grammar">grammar</a> to guide
us:</p><pre><code>List = Name [ &quot;,&quot; Name ]*
Name = /[a-z]+/</code></pre><p>I&#x27;ve used square brackets (<code class="inline">[</code>, <code class="inline">]</code>) to indicate grouping.
In words, the first rule says</p><blockquote><p>A <code class="inline">List</code> is a <code class="inline">Name</code>, followed by zero or more sequences of commas and <code class="inline">Name</code>s.</p></blockquote><p>and the second rule says</p><blockquote><p>A <code class="inline">Name</code> is a sequence of one or more alphabetic characters.</p></blockquote><p>So</p><pre><code>apples</code></pre><p>is a valid <code class="inline">List</code>, as is</p><pre><code>apples, bananas, oranges</code></pre><p>but none of</p><pre><code>, starts, with, a, comma
ends, with, a, comma,
missing, a comma</code></pre><p>are.</p><p>Let&#x27;s first write a lexer to split our source string into tokens.
In our case, a token is either a comma (<code class="inline">,</code>) or one or more lowercase characters
(<code class="inline">/[a-z]+/</code>).</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">re</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="regex">/,|[a-z]+/</span><span class="name">g</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">match</span><span class="punct">(</span><span class="name">re</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>The
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code class="inline">match</code></a>
method matches a string against the provided regular expression; the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match#return_value"><code class="inline">g</code> flag</a>
instructs it to return all matches.</p><p><code class="inline">lex</code> works as expected:</p><pre><code><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;apples, bananas, oranges&#x27;</span><span class="punct">)</span><span class="line">
</span><span class="comment">// =&gt; [&#x27;apples&#x27;, &#x27;,&#x27;, &#x27;bananas&#x27;, &#x27;,&#x27;, &#x27;oranges&#x27;]</span></code></pre><p>To write the parser we&#x27;ll follow the grammar, in the following sense:</p><ul><li>For each <em>definition</em> of a nonterminal <code class="inline">X</code> (e.g. <code class="inline">List</code>), we&#x27;ll write a corresponding <code class="inline">parseX</code> function (e.g. <code class="inline">parseList</code>).</li><li>For each <em>reference</em> to a nonterminal <code class="inline">Y</code>, we&#x27;ll call its <code class="inline">parseY</code> function.</li><li>For each (significant) terminal, we&#x27;ll check that the current token has the expected type, and return it.</li><li>For each <code class="inline">*</code>, we&#x27;ll write a loop.</li></ul><p>Here&#x27;s what that looks like:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseList</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">names</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="name">parseName</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;,&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">names</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseName</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">names</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseName</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="regex">/[a-z]+/</span><span class="op">.</span><span class="name">test</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;not a name&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><pre><code><span class="name">parseList</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;apples, bananas, oranges&#x27;</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="comment">// =&gt; [&#x27;apples&#x27;, &#x27;bananas&#x27;, &#x27;oranges&#x27;]</span></code></pre><div class="h2-container"><h2 id="Parsing nested lists">Parsing nested lists</h2><a href="#Parsing nested lists">#</a></div><p>Now that we can parse lists with a single separator, let&#x27;s parse <span>“<!-- -->nested<!-- -->”</span> lists.
Specifically, we&#x27;ll write a parser that transforms strings like</p><pre><code><span class="string">&#x27;a; b, c; d; e, f, g; h&#x27;</span></code></pre><p>into the nested arrays</p><pre><code><span class="punct">[</span><span class="punct">[</span><span class="string">&#x27;a&#x27;</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;b&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;c&#x27;</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;d&#x27;</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;e&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;f&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;g&#x27;</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;h&#x27;</span><span class="punct">]</span><span class="punct">]</span></code></pre><p>Thinking of <code class="inline">,</code> and <code class="inline">;</code> as operators, the <code class="inline">,</code> has a greater precedence—it
<span>“<!-- -->binds more tightly<!-- -->”</span>—than <code class="inline">;</code>.</p><p>Whereas we were previously interested in parsing lists of names, our current aim
is to parse lists <em>of lists</em>; the <span>“<!-- -->inner<!-- -->”</span> lists separated by commas (<code class="inline">,</code>) and
the <span>“<!-- -->outer<!-- -->”</span> lists separated by semicolons (<code class="inline">;</code>).</p><p>Here&#x27;s a grammar for our nested lists:</p><pre><code>OuterList = InnerList [ &quot;;&quot; InnerList ]*
InnerList = Name [ &quot;,&quot; Name ]*
Name      = /[a-z]+/</code></pre><p>Notice how the <span>“<!-- -->subgrammar<!-- -->”</span> for <code class="inline">InnerList</code> is <em>exactly</em> the same as the grammar
for <code class="inline">List</code> above.
So we already know how to parse <code class="inline">InnerList</code>s (and can simply rename and reuse
<code class="inline">parseList</code> for this purpose).
To parse an <code class="inline">OuterList</code>, we again follow the grammar:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseOuterList</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">innerLists</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="name">parseInnerList</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;;&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">innerLists</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseInnerList</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">innerLists</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>The code for parsing an <code class="inline">InnerList</code> and <code class="inline">Name</code> should look familiar:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseInnerList</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">names</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="name">parseName</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;,&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">names</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseName</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">names</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseName</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="regex">/[a-z]+/</span><span class="op">.</span><span class="name">test</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;not a name&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Finally, the lexer needs to be modified to match semicolons:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">re</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="regex">/,|;|[a-z]+/</span><span class="name">g</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">match</span><span class="punct">(</span><span class="name">re</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><pre><code><span class="name">parseOuterList</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;a; b, c; d; e, f, g; h&#x27;</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="comment">// =&gt; [[&#x27;a&#x27;], [&#x27;b&#x27;, &#x27;c&#x27;], [&#x27;d&#x27;], [&#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;], [&#x27;h&#x27;]]</span></code></pre><p>With similar additions we can parse lists of lists of lists, or even lists of
lists of lists of lists.</p><div class="h2-container"><h2 id="Taking stock">Taking stock</h2><a href="#Taking stock">#</a></div><p>Let&#x27;s replace our list separators (<code class="inline">;</code> and <code class="inline">,</code>) with <code class="inline">+</code> and <code class="inline">*</code>, and our names
with numbers:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">re</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="regex">/\+|\*|\d+/</span><span class="name">g</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">match</span><span class="punct">(</span><span class="name">re</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseSumExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">prodExprs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="name">parseProdExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;+&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">prodExprs</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseProdExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">prodExprs</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseProdExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">numbers</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;*&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">numbers</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">numbers</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="regex">/\d+/</span><span class="op">.</span><span class="name">test</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;not a number&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p><code class="inline">parseSumExpr</code> parses inhabitants of this grammar:</p><pre><code>SumExpr  = ProdExpr [ &quot;+&quot; ProdExpr ]*
ProdExpr = Number [ &quot;*&quot; Number ]*
Number   = /\d+/</code></pre><p>which is <span>“<!-- -->find-and-replace<!-- -->”</span>-isomorphic to the grammar for <code class="inline">OuterList</code>s above.
Not surprisingly, it produces similar results to <code class="inline">parseOuterList</code>:</p><pre><code><span class="name">parseSumExpr</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;1 + 2 * 3 + 4&#x27;</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="comment">// =&gt; [[&#x27;1&#x27;], [&#x27;2&#x27;, &#x27;3&#x27;], [&#x27;4&#x27;]]</span></code></pre><p>If we only wanted to support addition and multiplication, our job is finished.
We can write an evaluator for these expressions and call it a day:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">evalSumExpr</span><span class="punct">(</span><span class="name">prodExprs</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">sum</span><span class="punct">(</span><span class="name">prodExprs</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">evalProdExpr</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">evalProdExpr</span><span class="punct">(</span><span class="name">numbers</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">prod</span><span class="punct">(</span><span class="name">numbers</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">evalNumber</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">evalNumber</span><span class="punct">(</span><span class="name">x</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">Number</span><span class="punct">(</span><span class="name">x</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">sum</span><span class="punct">(</span><span class="name">xs</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">reduce</span><span class="punct">(</span><span class="punct">(</span><span class="name">sum</span><span class="punct">,</span><span class="space"> </span><span class="name">x</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">sum</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="name">x</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">prod</span><span class="punct">(</span><span class="name">xs</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">reduce</span><span class="punct">(</span><span class="punct">(</span><span class="name">prod</span><span class="punct">,</span><span class="space"> </span><span class="name">x</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">prod</span><span class="space"> </span><span class="op">*</span><span class="space"> </span><span class="name">x</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><pre><code><span class="name">evalSumExpr</span><span class="punct">(</span><span class="name">parseSumExpr</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;1 + 2 * 3 + 4&#x27;</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="comment">// =&gt; 11</span></code></pre><p>And with only the slightest bit of work, we can add single operators at
additional precedence levels.</p><p>However, our current approach isn&#x27;t able to accommodate multiple operators with
the same precedence.
Luckily we can fix this with only a few small adjustments, and we&#x27;ll produce a
more useful abstract syntax tree in the process.</p><div class="h2-container"><h2 id="Recovering operator info">Recovering operator info</h2><a href="#Recovering operator info">#</a></div><p>At the moment, we don&#x27;t have a good place to store information about the
operators that we&#x27;ve encountered (the arrays we&#x27;re returning are a kind of poor
man&#x27;s abstract syntax tree).
By adjusting the return type, we can make space for operator information as
well.
This will in turn allow us to handle any number of operators at a given
precedence level.</p><p>Let&#x27;s focus on a parser that handles addition only (that is, a simplified
version of <code class="inline">parseSumExpr</code> above):</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseSumExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">numbers</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;+&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">numbers</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">numbers</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>This currently produces an array, but we can instead produce a tree by <span>“<!-- -->folding<!-- -->”</span>
the <code class="inline">numbers</code> array:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseSumExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">numbers</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;+&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">numbers</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">first</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rest</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">numbers</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">rest</span><span class="op">.</span><span class="name">reduce</span><span class="punct">(</span><span class="punct">(</span><span class="name">lhs</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">(</span><span class="punct">{</span><span class="space"> </span><span class="name">lhs</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">first</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>This produces a tree where the <code class="inline">lhs</code> and <code class="inline">rhs</code> fields correspond to the lefthand
and righthand sides of an addition operation:</p><pre><code><span class="name">parseSumExpr</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;1 + 2 + 3&#x27;</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="comment">// =&gt; { lhs: { lhs: &#x27;1&#x27;, rhs: &#x27;2&#x27; }, rhs: &#x27;3&#x27; }</span></code></pre><p>Notice how the left associativity of the <code class="inline">+</code> operator is now encoded in the
structure of the tree, whereas previously it was squirrelled away in the
evaluator (see the definition of <code class="inline">sum</code>).</p><p>Recording the operator is now easy:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">first</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rest</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">numbers</span><span class="punct">;</span><span class="line">
</span><span class="keyword">return</span><span class="space"> </span><span class="name">rest</span><span class="op">.</span><span class="name">reduce</span><span class="punct">(</span><span class="punct">(</span><span class="name">lhs</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">(</span><span class="punct">{</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;+&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">first</span><span class="punct">)</span><span class="punct">;</span></code></pre><pre><code><span class="name">parseSumExpr</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;1 + 2 + 3&#x27;</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="comment">// =&gt; { op: &#x27;+&#x27;, lhs: { op: &#x27;+&#x27;, lhs: &#x27;1&#x27;, rhs: &#x27;2&#x27; }, rhs: &#x27;3&#x27; }</span></code></pre><p>But this works because we only support a single operator.
Instead, we need to record the operator <em>at the time we parse it</em>.
One approach is to maintain two separate arrays: one for numbers and another for
the operators between them.
We&#x27;d then weave these together to construct the final tree.</p><p>A simpler option is to <span>“<!-- -->fuse<!-- -->”</span> the left fold with the <code class="inline">parseSumExpr</code> function
itself.
This requires that we construct the tree <span>“<!-- -->online<!-- -->”</span>, as we parse numbers and
operators.
It looks like this:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseSumExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">sumExpr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;+&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">sumExpr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">sumExpr</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rhs</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">sumExpr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Note the resemblance between <code class="inline">parseSumExpr</code> and an imperative definition of
<code class="inline">foldLeft</code>/<code class="inline">reduce</code>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">foldLeft</span><span class="punct">(</span><span class="name">xs</span><span class="punct">,</span><span class="space"> </span><span class="name">fn</span><span class="punct">,</span><span class="space"> </span><span class="name">z</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">result</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">z</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">for</span><span class="space"> </span><span class="punct">(</span><span class="keyword">const</span><span class="space"> </span><span class="name">x</span><span class="space"> </span><span class="keyword">of</span><span class="space"> </span><span class="name">xs</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">result</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">fn</span><span class="punct">(</span><span class="name">result</span><span class="punct">,</span><span class="space"> </span><span class="name">x</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">result</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>With this revision it&#x27;s straightforward to incorporate subtraction:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">re</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="regex">/\+|-|\d+/</span><span class="name">g</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="comment">//             ^ Match `-` as well.</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">match</span><span class="punct">(</span><span class="name">re</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;+&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;-&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rhs</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="comment">// ...</span></code></pre><div class="h2-container"><h2 id="Associativity">Associativity</h2><a href="#Associativity">#</a></div><p>We&#x27;re now able to parse infix expressions containing any number of
<em>left-associative</em> operators, and any number of precedence levels.
To illustrate this we&#x27;ll write a parser for arithmetic expressions that include
addition, subtraction, multiplication, and division.</p><p>The lexer is old news by now:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">re</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="regex">/\+|-|\*|\/|\d+/</span><span class="name">g</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">match</span><span class="punct">(</span><span class="name">re</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>We have two precedence levels: one for addition and subtraction, and the other
for multiplication and division.
Since precedence levels may now contain multiple operators, we&#x27;ll name the
functions according to their level.</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr0</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr1</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;+&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;-&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr1</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rhs</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr1</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;*&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;/&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rhs</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>How about incorporating exponentiation?
This typically has a higher precedence than multiplication and division,
and is <em>right-associative</em>.</p><p>We proceed exactly like we did earlier, by fusing a right-fold with the parser
function:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr2</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;^&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr2</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="comment">//          ^^^^^^^^^^</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rhs</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>After modifying the lexer to match carets (<code class="inline">^</code>), and updating <code class="inline">parseExpr1</code> to
call <code class="inline">parseExpr2</code> where it formerly called <code class="inline">parseNumber</code>, this works as
expected.</p><pre><code><span class="name">parseExpr0</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;1 + 2 * 3 ^ 4 ^ 5&#x27;</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="comment">// =&gt;</span><span class="line">
</span><span class="comment">// {</span><span class="line">
</span><span class="comment">//     &quot;op&quot;: &quot;+&quot;,</span><span class="line">
</span><span class="comment">//     &quot;lhs&quot;: &quot;1&quot;,</span><span class="line">
</span><span class="comment">//     &quot;rhs&quot;: {</span><span class="line">
</span><span class="comment">//         &quot;op&quot;: &quot;*&quot;,</span><span class="line">
</span><span class="comment">//         &quot;lhs&quot;: &quot;2&quot;,</span><span class="line">
</span><span class="comment">//         &quot;rhs&quot;: {</span><span class="line">
</span><span class="comment">//             &quot;op&quot;: &quot;^&quot;,</span><span class="line">
</span><span class="comment">//             &quot;lhs&quot;: &quot;3&quot;,</span><span class="line">
</span><span class="comment">//             &quot;rhs&quot;: {</span><span class="line">
</span><span class="comment">//                 &quot;op&quot;: &quot;^&quot;,</span><span class="line">
</span><span class="comment">//                 &quot;lhs&quot;: &quot;4&quot;,</span><span class="line">
</span><span class="comment">//                 &quot;rhs&quot;: &quot;5&quot;</span><span class="line">
</span><span class="comment">//             }</span><span class="line">
</span><span class="comment">//         }</span><span class="line">
</span><span class="comment">//     }</span><span class="line">
</span><span class="comment">// }</span></code></pre><div class="h2-container"><h2 id="Combining precedence levels">Combining precedence levels</h2><a href="#Combining precedence levels">#</a></div><p>Our most recent parser contains 3 functions which are nearly identical.
We ought to be able to extract some common, more abstract function which can
then be specialized to a particular precedence level.</p><p>A first observation is that each <code class="inline">parseN</code> function has this shape:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseN</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseNPlus1</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="comment">/* ops at level N */</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="comment">/* ... */</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">?</span><span class="space"> </span><span class="name">parseN</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="name">parseNPlus1</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rhs</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>We can <span>“<!-- -->internalize<!-- -->”</span> the level (the <code class="inline">N</code> in <code class="inline">parseN</code>) as an additional argument
to this parsing function:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="comment">/* ops at level */</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="comment">/* ... */</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">?</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rhs</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>All that remains is to</p><ul><li>Provide a way to fetch the operators at a given <code class="inline">level</code></li><li>Determine an operator&#x27;s associativity</li><li>Determine when we should call <code class="inline">parseNumber</code></li></ul><p>Here&#x27;s a simple yet flexible approach: store the operator information in an
array of objects, where each object maps the operators at a given precedence
level to their associativities.</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">infixOp</span><span class="punct">(</span><span class="name">text</span><span class="punct">,</span><span class="space"> </span><span class="name">assoc</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;L&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="name">text</span><span class="punct">,</span><span class="space"> </span><span class="name">assoc</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">const</span><span class="space"> </span><span class="name">infixOps</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="name">infixOp</span><span class="punct">(</span><span class="string">&#x27;+&#x27;</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">infixOp</span><span class="punct">(</span><span class="string">&#x27;-&#x27;</span><span class="punct">)</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="name">infixOp</span><span class="punct">(</span><span class="string">&#x27;*&#x27;</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">infixOp</span><span class="punct">(</span><span class="string">&#x27;/&#x27;</span><span class="punct">)</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="name">infixOp</span><span class="punct">(</span><span class="string">&#x27;^&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;R&#x27;</span><span class="punct">)</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="punct">]</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">Object</span><span class="op">.</span><span class="name">fromEntries</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="comment">// =&gt; [ { &#x27;+&#x27;: &#x27;L&#x27;, &#x27;-&#x27;: &#x27;L&#x27; }, { &#x27;*&#x27;: &#x27;L&#x27;, &#x27;/&#x27;: &#x27;L&#x27; }, { &#x27;^&#x27;: &#x27;R&#x27; } ]</span></code></pre><p>With <code class="inline">infixOps</code> in hand</p><ul><li>We can retrieve the operators at any <code class="inline">level</code> with <code class="inline">Object.keys(infixOps[level])</code></li><li>An operator <code class="inline">op</code>&#x27;s associativity is just <code class="inline">infixOps[level][op]</code></li><li>We call <code class="inline">parseNumber</code> (instead of parsing an infix expression) when we&#x27;ve run out of precedence levels</li></ul><p>Adjusting <code class="inline">parseExpr</code> in this way gives</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">level</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">infixOps</span><span class="op">.</span><span class="name">length</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">parseNumber</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">ops</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">Object</span><span class="op">.</span><span class="name">keys</span><span class="punct">(</span><span class="name">infixOps</span><span class="punct">[</span><span class="name">level</span><span class="punct">]</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">ops</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="keyword">const</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">infixOps</span><span class="punct">[</span><span class="name">level</span><span class="punct">]</span><span class="punct">[</span><span class="name">op</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;R&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">?</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">        </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">        </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="line">
</span><span class="space">        </span><span class="name">rhs</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">

</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Not only is this revised parser smaller, it&#x27;s much easier to add additional
operators and precedence levels.</p><div class="h2-container"><h2 id="Parentheses, prefix, and postfix operators">Parentheses, prefix, and postfix operators</h2><a href="#Parentheses, prefix, and postfix operators">#</a></div><p>Finally, what about grouping subexpressions with parentheses?
Perhaps surprisingly, this requires almost no change to <code class="inline">parseExpr</code>.
Instead of parsing only <em>numbers</em> when we&#x27;ve run out of precedence levels, we
also check for a left parenthesis (<code class="inline">(</code>), which signals the start of a
parenthesized subexpression.
Upon seeing a left paren, we&#x27;ll parse an expression (the subexpression)
<em>starting back at level 0</em>, then look for a closing right paren.</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">level</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">infixOps</span><span class="op">.</span><span class="name">length</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">parseSimpleExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// ...</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseSimpleExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="regex">/\d+/</span><span class="op">.</span><span class="name">test</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;(&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Remove the left paren.</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">subExpr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">!</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;unmatched &quot;(&quot;&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">    </span><span class="comment">// Remove the right paren.</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">subExpr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;not a simple expression&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Prefix and postfix operators are handled similarly.
When parsing a <span>“<!-- -->simple expression<!-- -->”</span>, if we encounter a <code class="inline">-</code>, we remove it, parse
another simple expression, and return the appropriate negation node;
After parsing a simple expression, if we encounter a <code class="inline">!</code>, we remove it and
modify the previously parsed simple expression into a <span>“<!-- -->factorial<!-- -->”</span> node.</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseSimpleExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="regex">/\d+/</span><span class="op">.</span><span class="name">test</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;(&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Remove the left paren.</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">!</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;unmatched &quot;(&quot;&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">    </span><span class="comment">// Remove the right paren.</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;-&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Prefix operators.</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rand</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseSimpleExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">rand</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;not a simple expression&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="comment">// Postfix operators.</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;!&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">rand</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Why do we call <code class="inline">parseSimpleExpr</code> instead of <code class="inline">parseExpr</code> after seeing a prefix
operator?
We typically want prefix operators to bind more tightly than any infix
operators; calling <code class="inline">parseExpr</code> would result in <code class="inline">-1 + 2</code> being parsed as
<code class="inline">-(1 + 2)</code>, for instance.</p><p>It&#x27;s also worth noting that <code class="inline">parseSimpleExpr</code> gives all postfix operators a
higher precedence than prefix operators.
We could introduce a similar <span>“<!-- -->leveling<!-- -->”</span> scheme here to accommodate different
precedence levels for prefix and postfix operators, but this creates problems.</p><p>For instance, suppose we have a prefix operator <code class="inline">~</code>, and two postfix operators
<code class="inline">$</code> and <code class="inline">%</code>, where their relative precedences are <code class="inline">$ &lt; ~ &lt; %</code>.
That is, <code class="inline">~ a $</code> should be parsed as <code class="inline">(~ a) $</code>, whereas <code class="inline">~ a %</code> is equivalent to
<code class="inline">~ (a %)</code>.
How should <code class="inline">~ a $ %</code> be parsed?</p><p>Working from the outside-in, the expression resembles <code class="inline">~ [...] %</code>, and since <code class="inline">%</code>
has the greater precedence, this should be parsed as <code class="inline">~ ([...] %)</code>, and thus
<code class="inline">~ ((a $) %)</code>.
But working from the inside-out instead, the expression resembles <code class="inline">~ a $ [...]</code>,
and since <code class="inline">~</code> has the greater precedence, this should be parsed as <code class="inline">((~ a) $) %</code>.</p><p>Most mainstream languages simply sidestep the issue, as we&#x27;ve done here.</p><div class="h2-container"><h2 id="Grande finale">Grande finale</h2><a href="#Grande finale">#</a></div><p>This last listing presents our final parser in all its glory, along with an
evaluator for the syntax trees it produces.</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">re</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="regex">/\(|\)|\+|\-|\*|\/|\^|!|\d+/</span><span class="name">g</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">match</span><span class="punct">(</span><span class="name">re</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">level</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">infixOps</span><span class="op">.</span><span class="name">length</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">parseSimpleExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">ops</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">Object</span><span class="op">.</span><span class="name">keys</span><span class="punct">(</span><span class="name">infixOps</span><span class="punct">[</span><span class="name">level</span><span class="punct">]</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">ops</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="keyword">const</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">infixOps</span><span class="punct">[</span><span class="name">level</span><span class="punct">]</span><span class="punct">[</span><span class="name">op</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;R&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">?</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="name">level</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">        </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">        </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="line">
</span><span class="space">        </span><span class="name">rhs</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">

</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">infixOp</span><span class="punct">(</span><span class="name">text</span><span class="punct">,</span><span class="space"> </span><span class="name">assoc</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;L&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="name">text</span><span class="punct">,</span><span class="space"> </span><span class="name">assoc</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">const</span><span class="space"> </span><span class="name">infixOps</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="name">infixOp</span><span class="punct">(</span><span class="string">&#x27;+&#x27;</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">infixOp</span><span class="punct">(</span><span class="string">&#x27;-&#x27;</span><span class="punct">)</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="name">infixOp</span><span class="punct">(</span><span class="string">&#x27;*&#x27;</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">infixOp</span><span class="punct">(</span><span class="string">&#x27;/&#x27;</span><span class="punct">)</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="name">infixOp</span><span class="punct">(</span><span class="string">&#x27;^&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;R&#x27;</span><span class="punct">)</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="punct">]</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">Object</span><span class="op">.</span><span class="name">fromEntries</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseSimpleExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="regex">/\d+/</span><span class="op">.</span><span class="name">test</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;(&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Remove the left paren.</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">!</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;unmatched &quot;(&quot;&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">    </span><span class="comment">// Remove the right paren.</span><span class="line">
</span><span class="space">    </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;-&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rand</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseSimpleExpr</span><span class="punct">(</span><span class="name">ts</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">rand</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;not a simple expression&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;!&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">ts</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">ts</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">rand</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="regex">/\d+/</span><span class="op">.</span><span class="name">test</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">Number</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">Object</span><span class="op">.</span><span class="name">keys</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">rand</span><span class="space"> </span><span class="punct">}</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">arg</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rand</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="keyword">switch</span><span class="space"> </span><span class="punct">(</span><span class="name">op</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">case</span><span class="space"> </span><span class="string">&#x27;-&#x27;</span><span class="op">:</span><span class="line">
</span><span class="space">        </span><span class="keyword">return</span><span class="space"> </span><span class="op">-</span><span class="name">arg</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="keyword">case</span><span class="space"> </span><span class="string">&#x27;!&#x27;</span><span class="op">:</span><span class="line">
</span><span class="space">        </span><span class="keyword">return</span><span class="space"> </span><span class="name">fact</span><span class="punct">(</span><span class="name">arg</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">lhsArg</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">lhs</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhsArg</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rhs</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="keyword">switch</span><span class="space"> </span><span class="punct">(</span><span class="name">op</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">case</span><span class="space"> </span><span class="string">&#x27;+&#x27;</span><span class="op">:</span><span class="line">
</span><span class="space">        </span><span class="keyword">return</span><span class="space"> </span><span class="name">lhsArg</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="name">rhsArg</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="keyword">case</span><span class="space"> </span><span class="string">&#x27;-&#x27;</span><span class="op">:</span><span class="line">
</span><span class="space">        </span><span class="keyword">return</span><span class="space"> </span><span class="name">lhsArg</span><span class="space"> </span><span class="op">-</span><span class="space"> </span><span class="name">rhsArg</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="keyword">case</span><span class="space"> </span><span class="string">&#x27;*&#x27;</span><span class="op">:</span><span class="line">
</span><span class="space">        </span><span class="keyword">return</span><span class="space"> </span><span class="name">lhsArg</span><span class="space"> </span><span class="op">*</span><span class="space"> </span><span class="name">rhsArg</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="keyword">case</span><span class="space"> </span><span class="string">&#x27;/&#x27;</span><span class="op">:</span><span class="line">
</span><span class="space">        </span><span class="keyword">return</span><span class="space"> </span><span class="name">lhsArg</span><span class="space"> </span><span class="op">/</span><span class="space"> </span><span class="name">rhsArg</span><span class="punct">;</span><span class="line">
</span><span class="space">      </span><span class="keyword">case</span><span class="space"> </span><span class="string">&#x27;^&#x27;</span><span class="op">:</span><span class="line">
</span><span class="space">        </span><span class="keyword">return</span><span class="space"> </span><span class="name">lhsArg</span><span class="space"> </span><span class="op">*</span><span class="op">*</span><span class="space"> </span><span class="name">rhsArg</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">fact</span><span class="punct">(</span><span class="name">n</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">n</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="number">1</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">n</span><span class="space"> </span><span class="op">*</span><span class="space"> </span><span class="name">fact</span><span class="punct">(</span><span class="name">n</span><span class="space"> </span><span class="op">-</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>As promised:</p><pre><code><span class="name">evalExpr</span><span class="punct">(</span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;(1 + 4)! * -3^2&#x27;</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="comment">// =&gt; 1080</span></code></pre></main>
  </body>
</html>
