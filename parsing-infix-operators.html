<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <!-- KaTeX -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
      integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0"
      crossorigin="anonymous"
    />

    <link rel="stylesheet" href="./assets/main.css" />

    <title>You already know how to parse infix operators (DRAFT)</title>
  </head>

  <body>
    <main><h1>You already know how to parse infix operators (DRAFT)</h1><p>Our first goal is to parse infix expressions involving just a single operator.
The general case turns out to be not much more difficult that this.</p><div class="h2-container"><h2 id="A lexer">A lexer</h2><a href="#A lexer">#</a></div><p>Our parser will manipulate tokens, not the source string itself.
A <em>lexer</em> bridges this gap, extracting tokens from the source program.
This lexer maintains an index into the <code class="inline">source</code> string (<code class="inline">pos</code>), and a array of
<code class="inline">tokens</code> that we&#x27;ve seen so far.
On each turn of the inner loop, we&#x27;ll <span>“<!-- -->cut out<!-- -->”</span> the next token and push it onto
the array.</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">tokens</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">pos</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="comment">// Continue advancing `pos` while the predicate `pred` is true when applied to</span><span class="line">
</span><span class="space">  </span><span class="comment">// the character at `pos`.</span><span class="line">
</span><span class="space">  </span><span class="keyword">function</span><span class="space"> </span><span class="name">skipWhile</span><span class="punct">(</span><span class="name">pred</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">pos</span><span class="space"> </span><span class="op">&lt;</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">pred</span><span class="punct">(</span><span class="name">source</span><span class="punct">[</span><span class="name">pos</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">pos</span><span class="op">+</span><span class="op">+</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">function</span><span class="space"> </span><span class="name">skipWhitespace</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">skipWhile</span><span class="punct">(</span><span class="name">c</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="string">&#x27; \t\n\r&#x27;</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">c</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="comment">// Skip any leading whitespace.</span><span class="line">
</span><span class="space">  </span><span class="name">skipWhitespace</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">pos</span><span class="space"> </span><span class="op">&lt;</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">length</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Interesting parts go here.</span><span class="line">

</span><span class="space">    </span><span class="comment">// Skip any whitespace before the next token.</span><span class="line">
</span><span class="space">    </span><span class="name">skipWhitespace</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">tokens</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Within the loop, the question we need to answer is <span>“<!-- -->based on the current
character at <code class="inline">pos</code>, what type of token are we seeing?<!-- -->”</span>.
In many cases the answer is simple.
For instance, if the character at <code class="inline">source[pos]</code> is a <code class="inline">&#x27;(&#x27;</code>, then we&#x27;re seeing a
parenthesis token.
What if it&#x27;s a <code class="inline">q</code>?
In this case, we know that we&#x27;re seeing the beginning of a <em>name</em> (e.g. <code class="inline">quux</code>),
so we&#x27;ll continue advancing <code class="inline">pos</code> until we&#x27;re no longer seeing characters that
can be part of a name.</p><p>Here&#x27;s what that looks like:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">pos</span><span class="space"> </span><span class="op">&lt;</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">length</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">startPos</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">pos</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">c</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">source</span><span class="punct">[</span><span class="name">pos</span><span class="op">+</span><span class="op">+</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">c</span><span class="space"> </span><span class="keyword">in</span><span class="space"> </span><span class="name">simpleTypes</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">simpleTypes</span><span class="punct">[</span><span class="name">c</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">isDigit</span><span class="punct">(</span><span class="name">c</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">skipWhile</span><span class="punct">(</span><span class="name">isDigit</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;NUMBER&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">startsName</span><span class="punct">(</span><span class="name">c</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">skipWhile</span><span class="punct">(</span><span class="name">continuesName</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;NAME&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">`unknown token @ </span><span class="op">${</span><span class="name">pos</span><span class="op">}</span><span class="string">`</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">text</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">slice</span><span class="punct">(</span><span class="name">startPos</span><span class="punct">,</span><span class="space"> </span><span class="name">pos</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="name">tokens</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="punct">,</span><span class="space"> </span><span class="name">text</span><span class="space"> </span><span class="punct">}</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="name">skipWhitespace</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>We&#x27;ve mentioned a few items here that aren&#x27;t yet defined.
These are <code class="inline">simpleTypes</code>, <code class="inline">isDigit</code>, <code class="inline">startsName</code>, and <code class="inline">continuesName</code>:</p><pre><code><span class="keyword">const</span><span class="space"> </span><span class="name">simpleTypes</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="string">&#x27;+&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="punct">}</span><span class="punct">;</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">isDigit</span><span class="punct">(</span><span class="name">c</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="string">&#x27;0&#x27;</span><span class="space"> </span><span class="op">&lt;</span><span class="op">=</span><span class="space"> </span><span class="name">c</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">c</span><span class="space"> </span><span class="op">&lt;</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;9&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">startsName</span><span class="punct">(</span><span class="name">c</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="string">&#x27;a&#x27;</span><span class="space"> </span><span class="op">&lt;</span><span class="op">=</span><span class="space"> </span><span class="name">c</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">c</span><span class="space"> </span><span class="op">&lt;</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;z&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">continuesName</span><span class="punct">(</span><span class="name">c</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">startsName</span><span class="punct">(</span><span class="name">c</span><span class="punct">)</span><span class="space"> </span><span class="op">|</span><span class="op">|</span><span class="space"> </span><span class="name">isDigit</span><span class="punct">(</span><span class="name">c</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>We&#x27;re starting out with a single operator (<code class="inline">+</code>), but we&#x27;ll add more in due time.</p><p>How did we do?
Check that</p><pre><code><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;1 + quux + 42&#x27;</span><span class="punct">)</span></code></pre><p>produces the tokens we expect:</p><pre><code><span class="punct">[</span><span class="line">
</span><span class="space">  </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;NUMBER&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">text</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;1&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">text</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;+&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;NAME&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">text</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;quux&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">text</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;+&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;NUMBER&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">text</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;42&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="punct">]</span></code></pre><p>One last change before we get to the main event: we&#x27;re going to be performing
certain operations fairly often on the tokens emitted from lexer.
These are things like asking if there are any more tokens, peeking at the type
of the next token, and consuming the next token.
We can make our lives a bit easier by wrapping the <code class="inline">tokens</code> array in an object
that provides this functionality.</p><p>To that end, we&#x27;ll do something like this:</p><pre><code><span class="space">  </span><span class="comment">// In `lex`:</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Tokens</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>where</p><pre><code><span class="keyword">class</span><span class="space"> </span><span class="name">Tokens</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">constructor</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">this</span><span class="op">.</span><span class="name">tokens</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">tokens</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="keyword">this</span><span class="op">.</span><span class="name">tokens</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">&gt;</span><span class="space"> </span><span class="number">0</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">this</span><span class="op">.</span><span class="name">assertHasMore</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="keyword">this</span><span class="op">.</span><span class="name">tokens</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">this</span><span class="op">.</span><span class="name">assertHasMore</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="keyword">this</span><span class="op">.</span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="name">assertHasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="op">!</span><span class="keyword">this</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;unexpected EOF&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>We can now check if there&#x27;s another token with <code class="inline">hasMore</code>, <code class="inline">peek</code> at the
type of the next token, or consume it with <code class="inline">next</code>.
With that, we&#x27;re ready to begin.</p><div class="h2-container"><h2 id="A single infix operator">A single infix operator</h2><a href="#A single infix operator">#</a></div><p>Parsing expressions involving a single infix operator is almost as easy as
parsing a comma-separated list.
Since parsing a list is easier, let&#x27;s try that first.</p><p>First, add a comma <span>“<!-- -->operator<!-- -->”</span> to <code class="inline">simpleTypes</code>:</p><pre><code><span class="comment">// In `simpleTypes`:</span><span class="line">
</span><span class="string">&#x27;,&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;COMMA&#x27;</span><span class="punct">,</span></code></pre><p>and write the skeleton of <code class="inline">parseList</code>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseList</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ?</span><span class="line">
</span><span class="punct">}</span></code></pre><p>What should <code class="inline">parseList</code> do?
Lists are just sequences of numbers or names, separated by commas.
However, it&#x27;s easier to think of them in terms of the following grammar:</p><pre><code>List = Atom [ &quot;,&quot; Atom ]*
Atom = Number
     | Name</code></pre><p>In words: a <code class="inline">List</code> is a single <code class="inline">Atom</code>, followed by zero or more commas and
<code class="inline">Atom</code>s.
How do we transform this grammar into the body of <code class="inline">parseList</code>?
The standard trick is to</p><ul><li>Write a <code class="inline">parseX</code> function for each nonterminal <code class="inline">X</code> (in our case, <code class="inline">parseList</code> and <code class="inline">parseAtom</code>)</li><li>Replace each <code class="inline">*</code> with an appropriate loop</li><li>Consume terminals (<code class="inline">Number</code>, <code class="inline">Name</code>) and incorporate them into the output</li><li>Simply consume other tokens (e.g. <code class="inline">,</code>)</li></ul><p>Here&#x27;s what that looks like:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseList</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">atoms</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="name">atoms</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;COMMA&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Consume the comma.</span><span class="line">
</span><span class="space">    </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">atoms</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">atoms</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;NAME&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">text</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;NUMBER&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">Number</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">text</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;expected an atom&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Try it out!
Check that</p><pre><code><span class="name">parseList</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;apples, bananas, 42&#x27;</span><span class="punct">)</span><span class="punct">)</span></code></pre><p>produces</p><pre><code><span class="punct">[</span><span class="space"> </span><span class="string">&#x27;apples&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;bananas&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="number">42</span><span class="space"> </span><span class="punct">]</span></code></pre><p>If you&#x27;ve followed along so far, then the good news is that parsing expressions
like <code class="inline">1 + 2 + 3</code> is just as easy.
In fact, the grammar is identical:</p><pre><code>Expr = Atom [ &quot;+&quot; Atom ]*
Atom = Number
     | Name</code></pre><p>All that changes is how we construct the resulting abstract syntax tree.
Addition is <em>left-associative</em>, meaning compound additions like <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a + b + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></span> are
really shorthand for <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">(a + b) + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></span>.</p><p>One way to achieve this would be to write <code class="inline">parseExpr</code> identically to
<code class="inline">parseList</code>, and then <span>“<!-- -->fold<!-- -->”</span> the resulting <code class="inline">items</code> array into a tree:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">atoms</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="name">atoms</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Consume the &#x27;+&#x27; operator.</span><span class="line">
</span><span class="space">    </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">atoms</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">first</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rest</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">atoms</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">rest</span><span class="op">.</span><span class="name">reduce</span><span class="punct">(</span><span class="line">
</span><span class="space">    </span><span class="punct">(</span><span class="name">lhs</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">(</span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">first</span><span class="line">
</span><span class="space">  </span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>This works because <code class="inline">reduce</code> performs a <span>“<!-- -->left fold<!-- -->”</span> on its input, equivalent to</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">foldLeft</span><span class="punct">(</span><span class="name">xs</span><span class="punct">,</span><span class="space"> </span><span class="name">fn</span><span class="punct">,</span><span class="space"> </span><span class="name">y</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">xs</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">y</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">first</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rest</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">xs</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">y1</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">fn</span><span class="punct">(</span><span class="name">y</span><span class="punct">,</span><span class="space"> </span><span class="name">first</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">foldLeft</span><span class="punct">(</span><span class="name">rest</span><span class="punct">,</span><span class="space"> </span><span class="name">fn</span><span class="punct">,</span><span class="space"> </span><span class="name">y1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>We can illustrate the effect of <code class="inline">foldLeft</code> (or <code class="inline">reduce</code>) by walking through an example.
Since <code class="inline">foldLeft</code> has no side-effects, we make use of <span>“<!-- -->equational reasoning<!-- -->”</span>:</p><pre><code><span class="name">foldLeft</span><span class="punct">(</span><span class="punct">[</span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">,</span><span class="space"> </span><span class="number">3</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="name">fn</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">foldLeft</span><span class="punct">(</span><span class="punct">[</span><span class="number">2</span><span class="punct">,</span><span class="space"> </span><span class="number">3</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="name">fn</span><span class="punct">,</span><span class="space"> </span><span class="name">fn</span><span class="punct">(</span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="space">                           </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">foldLeft</span><span class="punct">(</span><span class="punct">[</span><span class="number">3</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="name">fn</span><span class="punct">,</span><span class="space"> </span><span class="name">fn</span><span class="punct">(</span><span class="name">fn</span><span class="punct">(</span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="space">                           </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">foldLeft</span><span class="punct">(</span><span class="punct">[</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="name">fn</span><span class="punct">,</span><span class="space"> </span><span class="name">fn</span><span class="punct">(</span><span class="name">fn</span><span class="punct">(</span><span class="name">fn</span><span class="punct">(</span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="number">3</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="space">                           </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">fn</span><span class="punct">(</span><span class="name">fn</span><span class="punct">(</span><span class="name">fn</span><span class="punct">(</span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="number">3</span><span class="punct">)</span></code></pre><p>In our case, <code class="inline">fn</code> transforms its two arguments into an object that looks like</p><pre><code><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="comment">/* first arg */</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="comment">/* second arg */</span><span class="punct">,</span><span class="line">
</span><span class="punct">}</span></code></pre><p>so</p><pre><code><span class="name">fn</span><span class="punct">(</span><span class="name">fn</span><span class="punct">(</span><span class="name">fn</span><span class="punct">(</span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="number">3</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">fn</span><span class="punct">(</span><span class="name">fn</span><span class="punct">(</span><span class="punct">{</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">1</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="number">3</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">fn</span><span class="punct">(</span><span class="punct">{</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">1</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">2</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="space"> </span><span class="number">3</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">1</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">2</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">3</span><span class="space"> </span><span class="punct">}</span></code></pre><p>where we&#x27;ve elided the <code class="inline">type</code> and <code class="inline">op</code> fields for clarity.</p><p>So parsing expressions involving a single left-associative operator is just a
matter of</p><ol><li>Parsing a list of <span>“<!-- -->atomic<!-- -->”</span> expressions, separated by the operator token</li><li>Folding the list of expressions into the appropriate tree</li></ol><p>What about a <em>right-associative</em> operator, like exponentiation (<code class="inline">^</code>)?
You guessed, it: just <code class="inline">reduceRight</code> instead (try it!).</p><p>This strategy works when we only have a single operator, but it can&#x27;t handle
multiple operators since we&#x27;re just throwing away the operator tokens at the
moment.
We could maintain an array of operators alongside the <code class="inline">atoms</code>, which we could
consult while folding.
However, in the wild it&#x27;s customary to <span>“<!-- -->fuse<!-- -->”</span> the fold into the loop instead.
By <span>“<!-- -->fuse<!-- -->”</span>, I mean that instead of building an <code class="inline">atoms</code> array and <em>then</em> folding
it into a tree, we&#x27;ll skip the intermediate array and just build the tree
directly:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Consume the &#x27;+&#x27; operator.</span><span class="line">
</span><span class="space">    </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>The new version looks different, but is doing essentially the same thing as the
original.
Work through a few examples until this makes sense; once you understand this,
you&#x27;re past the most difficult step.</p><p>One final note: this <span>“<!-- -->fusion<!-- -->”</span> step looks slightly different for
right-associative operators.
For instance, if we instead try to parse exponentiation (<code class="inline">^</code>) in this fashion,
the results are incorrect.
Rewriting <code class="inline">parseExpr</code> as</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;CARET&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;CARET&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>(and adding <code class="inline">&#x27;^&#x27;: &#x27;CARET&#x27;</code> to <code class="inline">simpleTypes</code>), we find that</p><pre><code><span class="name">parseExpr</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;a ^ b ^ c&#x27;</span><span class="punct">)</span><span class="punct">)</span></code></pre><p>produces</p><pre><code><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;CARET&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;CARET&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;a&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;b&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;c&#x27;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>How do we fix this?
One approach is to think more carefully about fusing the <code class="inline">reduceRight</code>
operation, but I find it easier to rethink part of the grammar.
Specifically, we can think of right-associative operators as satisfying this
alternative grammar:</p><pre><code>Expr = Atom [ &quot;^&quot; Expr ]*
                  ^^^^Parse an `Expr` here instead of an `Atom`.
Atom = Number
     | Name</code></pre><p>Try a few examples to see how this modification works.
Fixing <code class="inline">parseExpr</code> is simply a matter of calling <code class="inline">parseExpr</code> in the loop instead
of <code class="inline">parseAtom</code>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;CARET&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="comment">//          ^^^^^^^^^Parse an `Expr` here instead of an `Atom`.</span><span class="line">

</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;CARET&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><div class="h2-container"><h2 id="Multiple operators">Multiple operators</h2><a href="#Multiple operators">#</a></div><p>With the new <span>“<!-- -->fused<!-- -->”</span> version of <code class="inline">parseExpr</code>, we&#x27;re ready to parse more than one
operator, so long as they have the same <span>“<!-- -->precedence<!-- -->”</span> (more on that below).
Let&#x27;s add the <code class="inline">-</code> token to <code class="inline">simpleTypes</code>:</p><pre><code><span class="comment">// In `simpleTypes`:</span><span class="line">
</span><span class="string">&#x27;-&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;MINUS&#x27;</span><span class="punct">,</span></code></pre><p>To move from one operator to two operators, we need to:</p><ul><li>Check for either operator while <code class="inline">peek</code>ing the next token&#x27;s type</li><li>Incorporate the operator into the AST instead of discarding it</li></ul><p>This results in</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;MINUS&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Try it!</p><pre><code><span class="name">parseExpr</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;a + b - 42 + 2&#x27;</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>produces</p><pre><code><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;MINUS&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;a&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;b&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">42</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">2</span><span class="line">
</span><span class="punct">}</span></code></pre><div class="h2-container"><h2 id="Multiple precendence levels">Multiple precendence levels</h2><a href="#Multiple precendence levels">#</a></div><p>We can continue to add operators to <code class="inline">parseExpr</code>, but they will all have the same
<em>precedence</em>.
This is not how most languages work.
For instance, the expression <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>×</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a + b \times c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></span> is shorthand for <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>×</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a + (b \times
c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span></span> since <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span></span> has higher precedence than <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">+</span></span></span></span></span>.</p><p>The trick is to note that if you squint at an expression involving two
precedence levels, such as</p><pre><code>a + b * c + d * e * f</code></pre><p>it looks like</p><pre><code>a + X + Y</code></pre><p>where <code class="inline">X = b * c</code> and <code class="inline">Y = d * e * f</code>.</p><p>How can we perform this <span>“<!-- -->squinting<!-- -->”</span> in our parser?
Right now, <code class="inline">parseExpr</code> collects atoms, which are numbers and names.
But when we&#x27;re building an addition expression, we don&#x27;t want to parse atoms;
instead we want to parse expressions containing multiplications.
That&#x27;s what the <span>“<!-- -->squinting<!-- -->”</span> is about.</p><p>In words: <span>“<!-- -->To parse an expression involving additions, parse a list of <em>things</em>.
These <em>things</em> are expressions involving multiplication.
To parse an expression involving multiplication, parse a list of atoms.<!-- -->”</span></p><p>From a more grammatical angle, this looks like</p><pre><code>Expr0 = Expr1 [ &quot;+&quot; Expr1 ]*
Expr1 = Atom [ &quot;*&quot; Atom ]*
Atom  = Number
      | Name</code></pre><p>So instead of a single <code class="inline">parseExpr</code> function, we&#x27;ll now have two functions:
<code class="inline">parseExpr0</code>, which parses addition expressions whose constituents are
<em>products</em>, and <code class="inline">parseExpr1</code>, which parses multiplication expressions whose
constituents are <em>atoms</em>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr0</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr1</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr1</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr1</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;STAR&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>where we added</p><pre><code><span class="comment">// In `simpleTypes`:</span><span class="line">
</span><span class="string">&#x27;*&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;STAR&#x27;</span><span class="punct">,</span></code></pre><p>It works!</p><pre><code><span class="name">parseExpr0</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;a + b * c + d * e * f&#x27;</span><span class="punct">)</span><span class="punct">)</span></code></pre><p>produces the expected tree:</p><pre><code><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;a&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;STAR&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;b&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;c&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;STAR&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;STAR&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;d&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;e&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;f&#x27;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Adding more operators <em>within</em> a precedence level is simply a matter of adding
their operator <code class="inline">type</code> to the array being consulted at that level.
So, to add subtraction (<code class="inline">-</code>) and division (<code class="inline">/</code>), we just modify the loop
conditions of <code class="inline">parseExpr0</code> and <code class="inline">parseExpr1</code>:</p><pre><code><span class="comment">// In `parseExpr0`:</span><span class="line">
</span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;MINUS&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="comment">// In `parseExpr1`:</span><span class="line">
</span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;STAR&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;SLASH&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span></code></pre><p>where, as before</p><pre><code><span class="comment">// In `simpleTypes`:</span><span class="line">
</span><span class="string">&#x27;/&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;SLASH&#x27;</span><span class="punct">,</span></code></pre><p>What about adding an additional precedence level?
Let&#x27;s add exponetiation (<code class="inline">^</code>), which will also force us to handle a
right-associative operator.</p><p>We extend the grammar in the obvious way:</p><pre><code>Expr0 = Expr1 [ Op1 Expr1 ]*
Expr1 = Expr2 [ Op2 Expr2 ]*
Expr2 = Atom [ Op3 Atom ]*
Atom  = Number
      | Name

Op1 = &quot;+&quot; | &quot;-&quot;
Op2 = &quot;*&quot; | &quot;/&quot;
Op3 = &quot;^&quot;</code></pre><p>adjust <code class="inline">parseExpr1</code> so that it no longer calls <code class="inline">parseAtom</code>, but <code class="inline">parseExpr2</code> instead:</p><pre><code><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr2</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="comment">// ...</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr2</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>and write <code class="inline">parseExpr2</code>, <em>remembering what we learned earlier about
right-associative operators</em>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr2</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;CARET&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr2</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="comment">//          ^^^^^^^^^^Remember!</span><span class="line">

</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>But what about <em>mixing</em> left- and right-associative operators in the same
precedence level?
This is just a matter of consulting the operator, and calling either
<code class="inline">parseExprN+1</code> (for left-associative operators) or <code class="inline">parseExprN</code> (for
right-associative ones).</p><p>To illustrate this, let&#x27;s add a <code class="inline">@</code> operator (<code class="inline">&#x27;@&#x27;: &#x27;AT&#x27;</code>, in <code class="inline">simpleTypes</code>)
that&#x27;s left-associative and has the same precedence as <code class="inline">^</code>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr2</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;CARET&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;AT&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;CARET&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">op</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">?</span><span class="space"> </span><span class="name">parseExpr2</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>At this point, we can continue to add both left- and right-associative operators
<em>within</em> precedence levels, along with new precedence levels themselves.
However, the eagle-eyed readers have probably noticed that all of the
<code class="inline">parseExprN</code> functions are <em>nearly</em> identical.
We ought to be able to <span>“<!-- -->abstract out<!-- -->”</span> the core functionality they all share, and
that&#x27;s what we&#x27;ll do next.</p><div class="h2-container"><h2 id="Collapsing the parseExprN functions">Collapsing the <code class="inline">parseExprN</code> functions</h2><a href="#Collapsing the parseExprN functions">#</a></div><p>As you&#x27;ve keenly observed, each <code class="inline">parseExprN</code> function looks like this:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExprN</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="punct">[</span><span class="comment">/* operators */</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="comment">/* right-assoc. ops */</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">op</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">?</span><span class="space"> </span><span class="name">parseExprN</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="name">parseExprN</span><span class="op">+</span><span class="number">1</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>with the exception of the highest precedence level, which calls <code class="inline">parseAtom</code>
instead of <code class="inline">parseExprN+1</code>.</p><p>What if we just <span>“<!-- -->internalized<!-- -->”</span> the <code class="inline">N</code> in <code class="inline">parseExprN</code>?
That is, what if we wrote a new function <code class="inline">parseExpr(t, n)</code> that expects both
tokens <em>and</em> a new argument that represents the precedence level we&#x27;re currently
parsing?</p><p>A first shot at this looks like</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="comment">/* ops at level n */</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="comment">/* is `op` right-associative ? */</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">?</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="punct">)</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="comment">//                                      ^                 ^^^^^ Parse RHS at _next_ level.</span><span class="line">
</span><span class="space">    </span><span class="comment">//                                      ^ Parse RHS at _same_ level</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>It looks like all we need is a way to</p><ol><li>Get the types of all operators at a given level</li><li>Determine if an operator is left- or right-associative</li></ol><p>Here&#x27;s a pretty flexible approach:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">opsAtLevel</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">infixOps</span><span class="punct">[</span><span class="name">n</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">opTypes</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">opsAtLevel</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="punct">(</span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="space"> </span><span class="punct">}</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">type</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">opTypes</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">=</span><span class="line">
</span><span class="space">      </span><span class="name">opsAtLevel</span><span class="op">.</span><span class="name">find</span><span class="punct">(</span><span class="punct">(</span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="space"> </span><span class="punct">}</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">op</span><span class="punct">)</span><span class="op">.</span><span class="name">assoc</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;R&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">isRightAssoc</span><span class="space"> </span><span class="op">?</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="punct">)</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">const</span><span class="space"> </span><span class="name">infixOps</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="line">
</span><span class="space">    </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">assoc</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;L&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;MINUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">assoc</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;L&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="line">
</span><span class="space">    </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;STAR&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">assoc</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;L&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;SLASH&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">assoc</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;L&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;CARET&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">assoc</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;R&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="punct">]</span><span class="punct">;</span></code></pre><p>The <code class="inline">infixOps</code> array contains the various operators <span>“<!-- -->levels<!-- -->”</span>, along with their
associativity.
This makes it easy to add operators to existing levels, or add entirely new
levels.</p><p>It&#x27;s also <em>nearly</em> correct.
It currently blows the stack, since the first action we take within <code class="inline">parseExpr</code>
is to call <code class="inline">parseExpr</code> again (albeit with a greater index).
When entering <code class="inline">parseExpr</code> we need to check if there are any more operator levels
available, and if not, we parse an atom instead.
With those changes, <code class="inline">parseExpr</code> looks like this:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// If there are no more operator levels available, parse an atom. This is</span><span class="line">
</span><span class="space">  </span><span class="comment">// analogous to how `parseExpr2` called `parseAtom` before.</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">n</span><span class="space"> </span><span class="op">&gt;</span><span class="op">=</span><span class="space"> </span><span class="name">ops</span><span class="op">.</span><span class="name">length</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span></code></pre><div class="h2-container"><h2 id="Grouping with parentheses">Grouping with parentheses</h2><a href="#Grouping with parentheses">#</a></div><p>In most languages, parentheses can be used to group operations.
Adding this to our parser is just a matter of augmenting <code class="inline">parseAtom</code>: if we see
a left paren (<code class="inline">(</code>), we consume it, parse an expr <em>at level 0</em>, and anticipate a
right paren (<code class="inline">)</code>):</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;LPAREN&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">inner</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="name">t</span><span class="op">.</span><span class="name">expect</span><span class="punct">(</span><span class="string">&#x27;RPAREN&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">inner</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>where, as usual</p><pre><code><span class="comment">// In `simpleTypes`:</span><span class="line">
</span><span class="string">&#x27;(&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;LPAREN&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="string">&#x27;)&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;RPAREN&#x27;</span><span class="punct">,</span></code></pre><p>Additionally, we need to add an <code class="inline">expect</code> method to the <code class="inline">Tokens</code> class:</p><pre><code><span class="space">  </span><span class="name">expect</span><span class="punct">(</span><span class="name">type</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">this</span><span class="op">.</span><span class="name">assertHasMore</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">nextType</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="keyword">this</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">type</span><span class="space"> </span><span class="op">!</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">nextType</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">`expected </span><span class="op">${</span><span class="name">type</span><span class="op">}</span><span class="string">, not </span><span class="op">${</span><span class="name">nextType</span><span class="op">}</span><span class="string">`</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="keyword">this</span><span class="op">.</span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span></code></pre><p>And it works!</p><pre><code><span class="name">parseExpr</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;a * (1 + 2) ^ (apples - 3)&#x27;</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span></code></pre><p>produces</p><pre><code><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;STAR&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;a&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;CARET&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">2</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;MINUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;apples&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">3</span><span class="space"> </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><div class="h2-container"><h2 id="Prefix and postfix operators">Prefix and postfix operators</h2><a href="#Prefix and postfix operators">#</a></div><p>We can support prefix operators (like <code class="inline">-</code> in <code class="inline">-42</code>), by simply checking for them
while parsing <code class="inline">Atom</code>s.
Specifically</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;MINUS&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;UNAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>That is, if we see a <code class="inline">-</code> token, we consume it, parse an <em>atom</em>, and form the
appropriate <span>“<!-- -->unary application<!-- -->”</span> AST node.
Why do we call <code class="inline">parseAtom</code> here instead of <code class="inline">parseExpr</code>?
In most languages, prefix operators bind tighter than any infix operator.
For instance, <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>2</mn><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">-2 + 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span> is parsed as <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">(-2) + 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span></span> and not <span class="math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-(2 + 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span>.
Calling <code class="inline">parseAtom</code> encodes this idea.
It may help to think of this as being the same as calling <code class="inline">parseExpr(t,
infixOps.length)</code>, where the second argument (the <span>“<!-- -->level<!-- -->”</span>) is a precedence level
greater than any of the infix operators.
Since this just calls <code class="inline">parseAtom</code>, the two are equivalent.</p><p>We can generalize this in the same way we did for infix operators:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">prefixOps</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;UNAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">const</span><span class="space"> </span><span class="name">prefixOps</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;MINUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;STAR&#x27;</span><span class="punct">]</span><span class="punct">;</span></code></pre><p>We don&#x27;t need to include precedence or associativity information, because prefix
operators have none: they <span>“<!-- -->bind<!-- -->”</span> according to their distance from the expression
they act on, and it doesn&#x27;t make sense to speak of associativity here since they
only act on a single expression.</p><p>What about postfix operators?
As you probably guessed, a similar trick can be used.
After parsing an atom, we check if the next token is a postfix operator; if it
is, we consume it and construct an appropriate <span>“<!-- -->unary application<!-- -->”</span> node.
Do so requires revising <code class="inline">parseAtom</code> ever so slightly:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;NAME&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">text</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;NUMBER&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">Number</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">text</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;LPAREN&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">t</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">t</span><span class="op">.</span><span class="name">expect</span><span class="punct">(</span><span class="string">&#x27;RPAREN&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">prefixOps</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseAtom</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;UNAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">&#x27;expected an atom&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="comment">// Handle postfix operators.</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">hasMore</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">postfixOps</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">t</span><span class="op">.</span><span class="name">peek</span><span class="punct">(</span><span class="punct">)</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">t</span><span class="op">.</span><span class="name">next</span><span class="punct">(</span><span class="punct">)</span><span class="op">.</span><span class="name">type</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;UNAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="comment">// ...</span><span class="line">

</span><span class="keyword">const</span><span class="space"> </span><span class="name">postfixOps</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;BANG&#x27;</span><span class="punct">]</span><span class="punct">;</span></code></pre><p>and</p><pre><code><span class="comment">// In `simpleTypes`:</span><span class="line">
</span><span class="string">&#x27;!&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BANG&#x27;</span></code></pre><p>This lets us parse expressions like</p><pre><code><span class="string">&#x27;-(1 + 2)!&#x27;</span></code></pre><p>into</p><pre><code><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;UNAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;MINUS&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">expr</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;UNAPP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BANG&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="name">expr</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;BINAPP&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">op</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;PLUS&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">lhs</span><span class="op">:</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="op">:</span><span class="space"> </span><span class="number">2</span><span class="space"> </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>This approach gives all postfix operators higher precedence than any prefix
operator.
But what if we don&#x27;t want this?</p><p>I don&#x27;t actually know how to solve this problem in general!
Here&#x27;s an example that I&#x27;ve been thinking about: suppose we have 2 infix
operators (<code class="inline">-</code> and <code class="inline">~</code>), and one postfix operator (<code class="inline">!</code>), where <code class="inline">-</code> has the
lowest precedence, <code class="inline">!</code> has medium precedence, and <code class="inline">~</code> has the highest
precedence.
So <code class="inline">~a!</code> should be parsed as <code class="inline">(~a)!</code>, whereas <code class="inline">-a!</code> should be parsed as <code class="inline">-(a!)</code>.</p><p>How should we parse <code class="inline">~-a!</code>?</p><p>Reading <span>“<!-- -->outwards-in<!-- -->”</span>, <code class="inline">~</code> has a higher precedence than <code class="inline">!</code>, so it should be
parsed as <code class="inline">(~(-a))!</code>.
But reading <span>“<!-- -->inwards-out<!-- -->”</span>, <code class="inline">-</code> has a lower precedence than <code class="inline">!</code>, so it should be
parsed as <code class="inline">~(-(a!))</code>.</p><p>I don&#x27;t know how this ambiguous situation should be resolved.
Furthermore, the few grammars (e.g. C&#x27;s) that I consulted arrange things so that
postfix operators always take precedence over prefix operators.
This is exactly what <code class="inline">parseAtom</code> does, so maybe it&#x27;s okay.</p><div class="h2-container"><h2 id="Postfix-like constructions">Postfix-like constructions</h2><a href="#Postfix-like constructions">#</a></div><p>Finally, there&#x27;s a whole host of <span>“<!-- -->postfix-like<!-- -->”</span> constructions that we can now
parse.
The classic example is the ternary operator offered in many languages: <code class="inline">A ? B :
C</code>.
But we can also parse function applications (e.g. <code class="inline">quux(a, b, c)</code>), Rust-like
<code class="inline">struct</code> declarations (e.g. <code class="inline">Person { name: &quot;John&quot;, age: 42 }</code>), array access
(e.g. <code class="inline">quux[1][2]</code>)</p><div class="h2-container"><h2 id="Non-associative operators?">Non-associative operators?</h2><a href="#Non-associative operators?">#</a></div></main>
  </body>
</html>
