<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    
    <link rel="stylesheet" href="/notes/main.css" />
    <title>System F</title>
  </head>

  <body>
    <main><h1 id="System-F">System F</h1><p><em>Examples in this note use the syntax of <a href="https://github.com/wjlewis/propcalc2">propcalc2</a>.</em></p><p>In the simply typed lambda calculus</p><pre><code class="block code"><span class="keyword">let</span><span class="space"> </span><span class="name">id_A</span><span class="punct">:</span><span class="space"> </span><span class="name">A</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">A</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="keyword">supposing</span><span class="punct">(</span><span class="name">a</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">a</span><span class="line">
</span><span class="punct">}</span><span class="punct">;</span></code></pre><p>and</p><pre><code class="block code"><span class="keyword">let</span><span class="space"> </span><span class="name">id_B</span><span class="punct">:</span><span class="space"> </span><span class="name">B</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">B</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="keyword">supposing</span><span class="punct">(</span><span class="name">b</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">b</span><span class="line">
</span><span class="punct">}</span><span class="punct">;</span></code></pre><p>are two distinct terms: <code class="inline code">id_A</code> cannot be used in a setting where an inhabitant
of <code class="inline code">B =&gt; B</code> is expected, and vice-versa.
From a programming point of view, this prevents code-reuse.
From a logical perspective, it means that theorems must be re-proved for each
specific instance where they&#x27;re used.
System F fixes this issue by introducing <em>parameric polymorphism</em>.</p><h2 id="Parametric-polymorphism">Parametric polymorphism</h2><p>System F introduces <em>universally-quantified types</em> which express the desire for
a type to represent <em>all possible types</em>.
For example, the type</p><pre><code class="block code"><span class="keyword">∀</span><span class="space"> </span><span class="name">T</span><span class="punct">;</span><span class="space"> </span><span class="name">T</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">T</span></code></pre><p>subsumes the types of <code class="inline code">id_A</code> and <code class="inline code">id_B</code> above.
Terms of this type are constructed using a <!-- -->“<!-- -->type abstraction<!-- -->”<!-- -->:</p><pre><code class="block code"><span class="keyword">let</span><span class="space"> </span><span class="name">id</span><span class="punct">:</span><span class="space"> </span><span class="keyword">∀</span><span class="space"> </span><span class="name">T</span><span class="punct">;</span><span class="space"> </span><span class="name">T</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">T</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">&lt;</span><span class="name">A</span><span class="op">&gt;</span><span class="keyword">supposing</span><span class="punct">(</span><span class="name">t</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">t</span><span class="line">
</span><span class="punct">}</span><span class="punct">;</span></code></pre><p>To <em>use</em> <code class="inline code">id</code>, we need to first apply it to a type.
For example, we can redefine <code class="inline code">id_A</code> and <code class="inline code">id_B</code> above in terms of the more
general <code class="inline code">id</code>:</p><pre><code class="block code"><span class="keyword">let</span><span class="space"> </span><span class="name">id_A</span><span class="punct">:</span><span class="space"> </span><span class="name">A</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">A</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">id</span><span class="punct">&lt;</span><span class="name">A</span><span class="op">&gt;</span><span class="punct">;</span><span class="line">

</span><span class="keyword">let</span><span class="space"> </span><span class="name">id_B</span><span class="punct">:</span><span class="space"> </span><span class="name">B</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">B</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">id</span><span class="punct">&lt;</span><span class="name">B</span><span class="op">&gt;</span><span class="punct">;</span></code></pre><p>Just as <code class="inline code">supposing</code> (aka <code class="inline code">lambda</code>) allows us to parameterize terms by other
terms, angle brackets preceding a term allow us to paramterize it by a <em>type</em>.
That&#x27;s right: terms in System F may <em>contain types</em>.
This <!-- -->“<!-- -->level-mixing<!-- -->”<!-- --> of terms and types makes System F a nice stepping-stone
between the simply typed lambda calculus, and more sophisticated systems like
MLTT and CoC.</p><h2 id="Higher-rank-types">Higher-rank types</h2><p>Benefits</p><pre><code class="block code"><span class="keyword">let</span><span class="space"> </span><span class="name">mk_pair</span><span class="punct">:</span><span class="space"> </span><span class="keyword">∀</span><span class="space"> </span><span class="name">F</span><span class="punct">,</span><span class="space"> </span><span class="name">S</span><span class="punct">;</span><span class="space"> </span><span class="name">F</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">S</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">(</span><span class="keyword">∀</span><span class="space"> </span><span class="name">R</span><span class="punct">;</span><span class="space"> </span><span class="punct">(</span><span class="name">F</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">S</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">R</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">R</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">&lt;</span><span class="name">F</span><span class="punct">,</span><span class="space"> </span><span class="name">S</span><span class="op">&gt;</span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">supposing</span><span class="punct">(</span><span class="name">fst</span><span class="punct">,</span><span class="space"> </span><span class="name">snd</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">        </span><span class="punct">&lt;</span><span class="name">R</span><span class="op">&gt;</span><span class="keyword">supposing</span><span class="punct">(</span><span class="name">sel</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">            </span><span class="name">sel</span><span class="punct">(</span><span class="name">fst</span><span class="punct">,</span><span class="space"> </span><span class="name">snd</span><span class="punct">)</span><span class="line">
</span><span class="space">        </span><span class="punct">}</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="punct">;</span></code></pre><h3 id="Existential-types">Existential types</h3><pre><code class="block code"><span class="keyword">let</span><span class="space"> </span><span class="name">mk_pair</span><span class="punct">:</span><span class="space"> </span><span class="keyword">∀</span><span class="space"> </span><span class="name">F</span><span class="punct">,</span><span class="space"> </span><span class="name">S</span><span class="punct">;</span><span class="space"> </span><span class="keyword">∀</span><span class="space"> </span><span class="name">R</span><span class="punct">;</span><span class="space"> </span><span class="punct">(</span><span class="name">F</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">S</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">R</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">R</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">&lt;</span><span class="name">F</span><span class="punct">,</span><span class="space"> </span><span class="name">S</span><span class="op">&gt;</span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">supposing</span><span class="punct">(</span><span class="name">fst</span><span class="punct">,</span><span class="space"> </span><span class="name">snd</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">        </span><span class="keyword">$trust_me</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="punct">;</span></code></pre><h2 id="Impredicativity">Impredicativity</h2><p>System F is <em>impredicative</em>.
From Pierce in Chapter 23 of <em>Types and Programming Languages</em>:</p><blockquote><p>In general, a definition (of a set, a type, etc.) is called <!-- -->“<!-- -->impredicative<!-- -->”<!-- --> if
 it involves a quantifier whose domain includes the very thing being defined.
 For example, in System F, the type variable <code class="inline code">X</code> in the type <code class="inline code">T = ∀ X; X =&gt; X</code>
 ranges over all types, including <code class="inline code">T</code> itself (so that, for example, we can
 instantiate a term of type <code class="inline code">T</code> at type <code class="inline code">T</code>, yielding a function from <code class="inline code">T</code> to
 <code class="inline code">T</code>).</p></blockquote><pre><code class="block code"><span class="name">T</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="keyword">∀</span><span class="space"> </span><span class="name">X</span><span class="punct">;</span><span class="space"> </span><span class="name">X</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">X</span><span class="line">
</span><span class="comment">//    ^ X ranges over all possible types, including</span><span class="line">
</span><span class="comment">//      the type `∀ X; X =&gt; X`, that is, `T` itself!</span></code></pre><div class="footnotes"></div></main>
  </body>
</html>