<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="/main.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
    <title>This is not a compiler</title>
  </head>

  <body>
    <main><h1 id="This-is-not-a-compiler">This is not a compiler</h1><p>What&#x27;s the difference between a compiler and an interpreter?
A compiler transforms a program in one language into an equivalent program in
another language, whereas an interpreter <!-- -->“<!-- -->runs<!-- -->”<!-- --> a program.</p><p>Let&#x27;s try to formalize this.
We&#x27;ll let <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> and <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> be sets containing all legal programs written in two
languages, and <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></span> be the set of all possible <!-- -->“<!-- -->meanings<!-- -->”<!-- --> a program might have.
Finally, for each language <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">L_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>, suppose we&#x27;ve got some function</p><div class="block math"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>μ</mi><mi>n</mi></msub><mo>:</mo><msub><mi>L</mi><mi>n</mi></msub><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\mu_n : L_n \to M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></span></div><p>that produces the meaning of any program in <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">L_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>.</p><p>Then an interpreter for language <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is just a function</p><div class="block math"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>ι</mi><mn>1</mn></msub><mo>:</mo><msub><mi>L</mi><mn>1</mn></msub><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\iota_1 : L_1 \to M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">ι</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span></span></div><p>that produces the right meaning for each program in <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>.
That is,</p><div class="block math"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>p</mi><mo>∈</mo><msub><mi>L</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>ι</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>μ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall p \in L_1, \iota_1(p) = \mu_1(p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">ι</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span></span></span></span></span></div><p>Likewise, a compiler from <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> to <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> is just a function <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>:</mo><msub><mi>L</mi><mn>1</mn></msub><mo>→</mo><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\kappa : L_1 \to
L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">κ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> that translates any program in <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> into an <em>equivalent</em> program in <span class="inline math"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>.
So,</p><div class="block math"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>p</mi><mo>∈</mo><msub><mi>L</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>μ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>μ</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>κ</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall p \in L_1, \mu_1(p) = \mu_2(\kappa(p))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">∀</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">κ</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mclose">))</span></span></span></span></span></div><p>The slogan is: <em>interpreters reveal meaning; compilers preserve meaning</em>.</p><p>We&#x27;ve arrived at two simple, pleasing definitions which reveal the distinction
between a compiler and interpreter.
But this isn&#x27;t the whole story, and that&#x27;s the point of this note.
For the remainder of our time, we&#x27;ll look at a pathological example that
<em>technically</em> satisfies this definition of a compiler while <em>morally</em> failing to
be one.
This has absolutely no practical significance, but it&#x27;s a neat exercise, and it
also serves as an interesting example of the difficulty (or futility) of trying
to pin down even seemingly well-behaved concepts.</p><h2 id="The-big-picture">The big picture</h2><p>We&#x27;re going to write a program that <!-- -->“<!-- -->compiles<!-- -->”<!-- --> Scheme to JavaScript by simply
embedding a Scheme interpreter (written in JavaScript) along with the program we
asked it to compile.
Here&#x27;s the bird&#x27;s eye view:</p><pre><code class="block code"><span class="comment">// Transform a Scheme program into an equivalent JavaScript program by bundling</span><span class="line">
</span><span class="comment">// an interpreter with the original program.</span><span class="line">
</span><span class="keyword">function</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">program</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="string">`
// Run the provided Scheme program, producing its meaning.
function interpret(program) {
  // ...
}

interpret(\`</span><span class="op">${</span><span class="name">program</span><span class="op">}</span><span class="string">\`);
`</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Does this satisfy our formal definition above?
Is it a compiler?
We&#x27;ll return to these questions later.
But first, let&#x27;s write this thing.</p><h2 id="A-pocket-sized-Scheme">A pocket-sized Scheme</h2><p>The bulk of our <code class="inline code">compile</code> function is just a quoted Scheme interpreter, written
in JavaScript.
To keep the exercise interesting, the interpreter should at least be capable of
running a metacircular evaluator.
To keep it simple, we&#x27;ll forgo any of the bells and whistles that usually
accompany Scheme implementations (like a macro system, and even error messages).
The result is a <!-- -->“<!-- -->pocket-sized<!-- -->”<!-- --> Scheme that comes in under 200 lines.</p><p>First, let&#x27;s write a lexer that converts a string representation of a Scheme
program into <!-- -->“<!-- -->tokens<!-- -->”<!-- -->:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">re</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="regex">/\(|\)|\[|\]|&#x27;|[a-z+*\-&lt;&gt;=!?]+|\d+|#(t|f)/</span><span class="name">g</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">parts</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">match</span><span class="punct">(</span><span class="name">re</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="comment">// Convert &#x27;#t&#x27; and &#x27;#f&#x27; into `true` and `false`, and numeric strings into</span><span class="line">
</span><span class="space">  </span><span class="comment">// numbers.</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">parts</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">part</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;#t&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;#f&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">part</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">part</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;#t&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="op">!</span><span class="name">isNaN</span><span class="punct">(</span><span class="name">part</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">Number</span><span class="punct">(</span><span class="name">part</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">part</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>The function <code class="inline code">lex</code> first extracts all of the substrings from the source that
match the regular expression <code class="inline code">re</code>.
The <code class="inline code">g</code> flag causes
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code class="inline code">match</code></a>
to return <em>all</em> matches.
We then <code class="inline code">map</code> over the extracted parts, converting Scheme boolean and number
tokens into JavaScript booleans and numbers, which will make evaluation easier.</p><p>For example,</p><pre><code class="block code"><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;(and #t (&gt; 2 1))&#x27;</span><span class="punct">)</span></code></pre><p>produces the array:</p><pre><code class="block code"><span class="punct">[</span><span class="string">&#x27;(&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;and&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="keyword">true</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;(&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;&gt;&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">]</span></code></pre><p>Next, the dreaded parser.
We&#x27;ll write a classic recursive-descent parser that represents s-expressions
using JavaScript arrays.
We won&#x27;t handle dotted pairs, which simplifies both the parser and the rest of
the intepreter.</p><p>Here&#x27;s a grammar to guide our efforts:</p><pre><code class="block code">Program = Expr*
Expr = Name
     | Number
     | Boolean
     | &quot;(&quot; Expr* &quot;)&quot;
     | &quot;[&quot; Expr* &quot;]&quot;
     | &quot;&#x27;&quot; Expr</code></pre><p>We can translate this grammar into JavaScript by</p><ul><li><p>writing a <code class="inline code">parseX</code> function for each nonterminal <code class="inline code">X</code> (i.e. <code class="inline code">parseProgram</code> and
 <code class="inline code">parseExpr</code>)</p></li><li><p>replacing each <code class="inline code">*</code> with an appropriate loop</p></li><li><p>replacing each reference to a nonterminal <code class="inline code">X</code> on the righthand side with a
 (potentially recursive) call to the <code class="inline code">parseX</code> function</p></li><li><p>just emit the token for terminals (i.e. names, numbers, and booleans)</p></li></ul><p>Working step-by-step, we write a <code class="inline code">parseProgram</code> function to parse <code class="inline code">Program</code>s:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">parseProgram</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">exprs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">tokens</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">&gt;</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">exprs</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">exprs</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Easy enough, but what about parsing <code class="inline code">Expr</code>essions?</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;(&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;[&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">parseList</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">tokens</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&quot;&#x27;&quot;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">quoted</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;quote&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">quoted</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p><code class="inline code">parseExpr</code> examines the first token.
If it&#x27;s an open parenthesis or bracket, it parses a <!-- -->“<!-- -->list<!-- -->”<!-- --> (see below); if it&#x27;s
a quote (<code class="inline code">&#x27;</code>), it consumes the token, parses an expression (see the grammar),
and synthesizes an appropriate <code class="inline code">(quote ...)</code> s-expression; and if it&#x27;s an atom
(name, number, or boolean), it simply consumes and returns the token.</p><p>That just leaves <code class="inline code">parseList</code>:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">parseList</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">opener</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">closers</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="string">&#x27;(&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;[&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;]&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="comment">// Determine if we&#x27;re looking for a &#x27;)&#x27; or &#x27;]&#x27;.</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">closer</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">closers</span><span class="punct">[</span><span class="name">opener</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">exprs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">tokens</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">&gt;</span><span class="space"> </span><span class="number">0</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">tokens</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">!</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">closer</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">exprs</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="comment">// Consume the closing token.</span><span class="line">
</span><span class="space">  </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">exprs</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Again, this just does what the grammar indicates.
(This implementation of <code class="inline code">parseList</code> combines the nearly identical cases of
parenthesized <code class="inline code">(...)</code> and bracketed <code class="inline code">[...]</code> lists, but we could just as well
have written separate functions for each.)</p><p>We can now parse programs into array-based abstract syntax trees.
For example:</p><pre><code class="block code"><span class="name">parseProgram</span><span class="punct">(</span><span class="line">
</span><span class="space">  </span><span class="name">lex</span><span class="punct">(</span><span class="string">`
(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))

(map fact &#x27;(0 1 2 3 4 5))
`</span><span class="punct">)</span><span class="line">
</span><span class="punct">)</span></code></pre><p>produces</p><pre><code class="block code"><span class="punct">[</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;define&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;fact&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;n&#x27;</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">]</span><span class="punct">]</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;map&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;fact&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;quote&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">]</span><span class="punct">]</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="punct">]</span></code></pre><p>With that, we&#x27;ve arrived at the main event: evaluation.</p><p>To evaluate a program, we simply evaluate each expression in the program:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">evalProgram</span><span class="punct">(</span><span class="name">program</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">for</span><span class="space"> </span><span class="punct">(</span><span class="keyword">const</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="keyword">of</span><span class="space"> </span><span class="name">program</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>All of the action occurs in <code class="inline code">evalExpr</code>, which performs a case analysis on the
<code class="inline code">expr</code> we give it:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;number&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;boolean&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">expr</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Names</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Compound expressions (e.g. `(let ([x 2]) ...)`)</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Literals (numbers and booleans) evaluate to themselves.
That is, <code class="inline code">evalExpr(42, &lt;anything&gt;)</code> produces <code class="inline code">42</code>.</p><p>What about other expression types?
Let&#x27;s work through one case at a time.
The value of a name is just the value it&#x27;s bound to in the <code class="inline code">env</code>rionment:</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">lookup</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>We&#x27;ll represent environments as objects with a <code class="inline code">bindings</code> field whose value is
an object associating names with values, and a <code class="inline code">base</code> field that points to a
(possibly empty) environment.
To <code class="inline code">lookup</code> the value bound to a name in an environment, we check if the name
occurs in the environment&#x27;s <code class="inline code">bindings</code>; if not, we recursively check the <code class="inline code">base</code>
environment:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">lookup</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">name</span><span class="space"> </span><span class="keyword">in</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">env</span><span class="op">.</span><span class="name">base</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">lookup</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">base</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">`unbound name: </span><span class="op">${</span><span class="name">name</span><span class="op">}</span><span class="string">`</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>As always, let&#x27;s try an example.
Suppose</p><pre><code class="block code"><span class="keyword">const</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">bindings</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">a</span><span class="op">:</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="name">b</span><span class="op">:</span><span class="space"> </span><span class="number">2</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">base</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">bindings</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">a</span><span class="op">:</span><span class="space"> </span><span class="number">42</span><span class="punct">,</span><span class="space"> </span><span class="name">c</span><span class="op">:</span><span class="space"> </span><span class="keyword">true</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="punct">}</span><span class="punct">;</span></code></pre><p>Then <code class="inline code">lookup(&#x27;a&#x27;, env)</code> produces <code class="inline code">1</code>, <code class="inline code">lookup(&#x27;b&#x27;, env)</code> is <code class="inline code">2</code>, <code class="inline code">lookup(&#x27;c&#x27;,
env)</code> is <code class="inline code">true</code>, and <code class="inline code">lookup(&#x27;quux&#x27;, env)</code> throws an error.</p><p>Returning to <code class="inline code">evalExpr</code>, all that remains are compound expressions, which we&#x27;ve
represented as arrays.
We decide what to do based on the first element.
For example, if the expression begins with <code class="inline code">[&#x27;if&#x27;, ...]</code>, we evaluate either
the true <!-- -->“<!-- -->arm<!-- -->”<!-- --> or false arm according to the value of the test expression.</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">first</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rest</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;if&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">trueExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">falseExpr</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">isTrue</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">isTrue</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">trueExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">falseExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// ...</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p><code class="inline code">lambda</code> expressions evaluate to closures, which we represent as objects
containing the lambda&#x27;s parameters, body, and current environment:</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;lambda&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p><code class="inline code">quote</code> expressions simply return the quoted expression <em>as a value</em>:</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;quote&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">rest</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>We <!-- -->“<!-- -->desugar<!-- -->”<!-- --> <code class="inline code">let</code> expressions into equivalent applications of <code class="inline code">lambda</code>
expressions.
For example,</p><pre><code class="block code"><span class="punct">(</span><span class="keyword">let</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="name">x</span><span class="space"> </span><span class="number">1</span><span class="punct">]</span><span class="space"> </span><span class="punct">[</span><span class="name">y</span><span class="space"> </span><span class="number">2</span><span class="punct">]</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="punct">(</span><span class="name">+</span><span class="space"> </span><span class="name">x</span><span class="space"> </span><span class="name">y</span><span class="punct">)</span><span class="punct">)</span></code></pre><p>becomes</p><pre><code class="block code"><span class="punct">(</span><span class="punct">(</span><span class="keyword">lambda</span><span class="space"> </span><span class="punct">(</span><span class="name">x</span><span class="space"> </span><span class="name">y</span><span class="punct">)</span><span class="line">
</span><span class="space">   </span><span class="punct">(</span><span class="name">+</span><span class="space"> </span><span class="name">x</span><span class="space"> </span><span class="name">y</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="space"> </span><span class="number">1</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span></code></pre><p>We could just as well <!-- -->“<!-- -->directly<!-- -->”<!-- --> evaluate <code class="inline code">let</code> expressions, but this lets us
keep the core of the evaluator smaller.</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;let&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">desugarLet</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>where</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">desugarLet</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">_let</span><span class="punct">,</span><span class="space"> </span><span class="name">bindings</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">params</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">bindings</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="punct">(</span><span class="punct">[</span><span class="name">param</span><span class="punct">,</span><span class="space"> </span><span class="name">_rand</span><span class="punct">]</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">param</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">rands</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">bindings</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="punct">(</span><span class="punct">[</span><span class="name">_param</span><span class="punct">,</span><span class="space"> </span><span class="name">rand</span><span class="punct">]</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">rand</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">lambda</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;lambda&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="name">lambda</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rands</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Try it out!</p><p>Assignments <em>mutate</em> a binding in the current environment:</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;set!&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">value</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rhs</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="name">assign</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">value</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">value</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>where</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">assign</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">value</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">name</span><span class="space"> </span><span class="keyword">in</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">value</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">env</span><span class="op">.</span><span class="name">base</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">assign</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">value</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">base</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">`unbound name: </span><span class="op">${</span><span class="name">name</span><span class="op">}</span><span class="string">`</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Likewise, <code class="inline code">cond</code> gets desugared into a sequence of <code class="inline code">if</code>s:</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;cond&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">desugarCond</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>where</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">desugarCond</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">_cond</span><span class="punct">,</span><span class="space"> </span><span class="name">clauses</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">clauses</span><span class="op">.</span><span class="name">reduceRight</span><span class="punct">(</span><span class="line">
</span><span class="space">    </span><span class="punct">(</span><span class="name">falseExpr</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">trueExpr</span><span class="punct">]</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">trueExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">falseExpr</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="number">0</span><span class="line">
</span><span class="space">  </span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Try it!</p><pre><code class="block code"><span class="name">desugarCond</span><span class="punct">(</span><span class="line">
</span><span class="space">  </span><span class="name">parseExpr</span><span class="punct">(</span><span class="line">
</span><span class="space">    </span><span class="name">lex</span><span class="punct">(</span><span class="string">`
(cond [(= n 1) 1]
      [(= n 2) 42]
      [#t      123])
`</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="punct">)</span><span class="line">
</span><span class="punct">)</span></code></pre><p>produces</p><pre><code class="block code"><span class="punct">[</span><span class="line">
</span><span class="space">  </span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;=&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;n&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="number">1</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;=&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;n&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="number">42</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="keyword">true</span><span class="punct">,</span><span class="space"> </span><span class="number">123</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">]</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="punct">]</span></code></pre><p>Definitions add a binding for the defined name, <em>mutating</em> the current
environment:</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;define&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">isDefiningName</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">rest</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">isDefiningName</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rhs</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="punct">[</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">params</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">lambda</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;lambda&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">lambda</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>Here we support defining both names <em>and</em> functions:</p><pre><code class="block code"><span class="punct">(</span><span class="keyword">define</span><span class="space"> </span><span class="name">quux</span><span class="space"> </span><span class="number">42</span><span class="punct">)</span><span class="line">

</span><span class="punct">(</span><span class="keyword">define</span><span class="space"> </span><span class="punct">(</span><span class="name">square</span><span class="space"> </span><span class="name">x</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="punct">(</span><span class="name">*</span><span class="space"> </span><span class="name">x</span><span class="space"> </span><span class="name">x</span><span class="punct">)</span><span class="punct">)</span></code></pre><p>Sequences are evaluated by evaluating each expression in order.
The value of a sequence is the value of the final expression:</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;begin&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">init</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="op">.</span><span class="name">slice</span><span class="punct">(</span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="op">-</span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">last</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">[</span><span class="name">rest</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">-</span><span class="space"> </span><span class="number">1</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">for</span><span class="space"> </span><span class="punct">(</span><span class="keyword">const</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="keyword">of</span><span class="space"> </span><span class="name">init</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">last</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>All that remains are applications:</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">rator</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rands</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rator</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">args</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rands</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">rand</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rand</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;function&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">op</span><span class="punct">(</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">args</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="punct">}</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">op</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">bindings</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">Object</span><span class="op">.</span><span class="name">fromEntries</span><span class="punct">(</span><span class="name">zip</span><span class="punct">(</span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">args</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">env1</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">bindings</span><span class="punct">,</span><span class="space"> </span><span class="name">base</span><span class="op">:</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">env1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>We&#x27;ll include some primitives (like <code class="inline code">+</code>, <code class="inline code">cons</code>, etc.) as JavaScript functions,
which is why we need to check the operator&#x27;s type.
If the operator is a JavaScript function, we simply apply it to the arguments;
if it&#x27;s a closure we do the usual thing: extend the environment by binding the
closure&#x27;s parameters to the arguments, and evaluate the body in this new
extended environment.</p><p>Constructing the new bindings is a simple matter of <code class="inline code">zip</code>ping the names and args
together, and turning the resulting array into an object.</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">zip</span><span class="punct">(</span><span class="name">xs</span><span class="punct">,</span><span class="space"> </span><span class="name">ys</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="punct">(</span><span class="name">x</span><span class="punct">,</span><span class="space"> </span><span class="name">i</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">[</span><span class="name">x</span><span class="punct">,</span><span class="space"> </span><span class="name">ys</span><span class="punct">[</span><span class="name">i</span><span class="punct">]</span><span class="punct">]</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>We&#x27;re now ready to define <code class="inline code">interpret</code>:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">interpret</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">env0</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">bindings</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;+&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;-&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">-</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;*&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">*</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;&lt;&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">&lt;</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;=&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;number?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;number&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;boolean?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;boolean&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;symbol?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;eq?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;empty?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">xs</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">cons</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">head</span><span class="punct">,</span><span class="space"> </span><span class="name">tail</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">[</span><span class="name">head</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">tail</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">head</span><span class="op">:</span><span class="space"> </span><span class="name">xs</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">xs</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">tail</span><span class="op">:</span><span class="space"> </span><span class="name">xs</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">slice</span><span class="punct">(</span><span class="number">1</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">debug</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">console</span><span class="op">.</span><span class="name">log</span><span class="punct">(</span><span class="name">showValue</span><span class="punct">(</span><span class="name">v</span><span class="punct">)</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="name">evalProgram</span><span class="punct">(</span><span class="name">parseProgram</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">env0</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p><code class="inline code">interpret</code> just glues all of the pieces together and provides a few primitives
for working with numbers and lists.
We also include a <code class="inline code">debug</code> primitive for printing to the console, which relies on
<code class="inline code">showValue</code>:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">showValue</span><span class="punct">(</span><span class="name">v</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">Array</span><span class="op">.</span><span class="name">isArray</span><span class="punct">(</span><span class="name">v</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="string">`(</span><span class="op">${</span><span class="name">v</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">showValue</span><span class="punct">)</span><span class="op">.</span><span class="name">join</span><span class="punct">(</span><span class="string">&#x27; &#x27;</span><span class="punct">)</span><span class="op">}</span><span class="string">)`</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;object&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="string">&#x27;#&lt;closure&gt;&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">v</span><span class="op">.</span><span class="name">toString</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Let&#x27;s give this baby a whirl:</p><pre><code class="block code"><span class="name">interpret</span><span class="punct">(</span><span class="string">`
(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))

(define (map fn xs)
  (if (empty? xs)
      &#x27;()
      (cons (fn (head xs))
            (map fn (tail xs)))))

(define quux (map fact &#x27;(0 1 2 3 4 5)))

(debug quux)
`</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="comment">// =&gt; (1 1 2 6 24 120)</span></code></pre><h2 id="The-compiler,-finally">The compiler, finally</h2><p>Time for the payoff.
All that&#x27;s left is to write <code class="inline code">compile</code>, which simply interpolates the provided
program into a template containing the interpreter code we just wrote.</p><p>Since we&#x27;re going to paste the interpreter source code inside a template string,
we need to be careful to escape all backticks (<code class="inline code">`</code>); we also need to escape
dollar signs (`$<code class="inline code">) and escape characters (</code>\`) as well.
This is easy enough to do manually, but we can also automate it with a little
script.</p><p>If the following is saved in a file named <em>quote.js</em>:</p><pre><code class="block code"><span class="name">process</span><span class="op">.</span><span class="name">stdin</span><span class="line">
</span><span class="space">  </span><span class="op">.</span><span class="name">setEncoding</span><span class="punct">(</span><span class="string">&#x27;utf-8&#x27;</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="comment">// Replace backticks (`), dollar signs ($), and escape characters (\) with an</span><span class="line">
</span><span class="space">  </span><span class="comment">// escaped version, e.g. $ -&gt; \$.</span><span class="line">
</span><span class="space">  </span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">chunk</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">chunk</span><span class="op">.</span><span class="name">replace</span><span class="punct">(</span><span class="regex">/`|\$|\\/</span><span class="name">g</span><span class="punct">,</span><span class="space"> </span><span class="name">c</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="string">`\\</span><span class="op">${</span><span class="name">c</span><span class="op">}</span><span class="string">`</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="op">.</span><span class="name">pipe</span><span class="punct">(</span><span class="name">process</span><span class="op">.</span><span class="name">stdout</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>and the interpreter source is saved in <em>pocket-scheme.js</em>, then</p><pre><code class="block code">$ node quote.js &lt; pocket-scheme.js &gt; quoted-interpreter.txt</code></pre><p>will save the quoted interpreter source in <em>quoted-interpreter.txt</em>.</p><p>In a new file (which I&#x27;m calling <em>not-a-compiler.js</em>), copy the quoted
interpreter source into the body of a function named <code class="inline code">compile</code>, along with a
(quoted) invocation of the <code class="inline code">interpret</code> function on the <code class="inline code">source</code> of the program
to be <!-- -->“<!-- -->compiled<!-- -->”<!-- -->:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">interpreterSource</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="string">`
function lex(source) {
  const re = /\\(|\\)|\\[|\\]|&#x27;|[a-z+*\\-&lt;&gt;=!?]+|\\d+|#(t|f)/g;
  const parts = source.match(re);
...
`</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="string">`
</span><span class="op">${</span><span class="name">interpreterSource</span><span class="op">}</span><span class="string">

interpret(\`</span><span class="op">${</span><span class="name">source</span><span class="op">}</span><span class="string">\`);
`</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p><em>The full listing is available <a href="https://gist.github.com/wjlewis/a85a5b9a66875d82c1155a59474aee7d">here</a>.</em></p><p>Finally, to make our <!-- -->“<!-- -->compiler<!-- -->”<!-- --> a little more ergonomic, let&#x27;s read input
programs from <code class="inline code">stdin</code> and write our compiled output to <code class="inline code">stdout</code>:</p><pre><code class="block code"><span class="keyword">const</span><span class="space"> </span><span class="name">fs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">require</span><span class="punct">(</span><span class="string">&#x27;fs&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">const</span><span class="space"> </span><span class="name">source</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">fs</span><span class="op">.</span><span class="name">readFileSync</span><span class="punct">(</span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;utf-8&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="name">fs</span><span class="op">.</span><span class="name">writeFileSync</span><span class="punct">(</span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>We can now compile Scheme files by executing</p><pre><code class="block code">$ node not-a-compiler.js &lt; my-program.scm</code></pre><p>or compile-and-execute via</p><pre><code class="block code">$ node not-a-compiler.js &lt; my-program.scm | node</code></pre><p>or compose on-the-fly with</p><pre><code class="block code">$ node not-a-compiler.js | node
(define (fib n)
  (cond [(= n 1) 1]
        [(= n 2) 1]
        [#t      (+ (fib (- n 1))
                    (fib (- n 2)))]))

(debug (fib 10))
Ctrl+D
55</code></pre><h2 id="Is-this-a-compiler?">Is this a compiler?</h2><p>Yes, according to the definition above, since</p><pre><code class="block code">$ node not-a-compiler.js &lt; my-prog.scm | node</code></pre><p>and</p><pre><code class="block code">$ scheme my-prog.scm</code></pre><p>produce the same result<a id="__footnote_ref_1" href="#__footnote_1" class="footnote-ref"><sup>1</sup></a>.</p><p>However, its output tells a different story.
We&#x27;d expect our compiler to transform the scheme program</p><pre><code class="block code"><span class="punct">(</span><span class="name">debug</span><span class="space"> </span><span class="punct">(</span><span class="name">+</span><span class="space"> </span><span class="number">1</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span><span class="punct">)</span></code></pre><p>into something like</p><pre><code class="block code"><span class="name">console</span><span class="op">.</span><span class="name">log</span><span class="punct">(</span><span class="number">1</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>instead it produces this monstrosity:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseProgram</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="comment">// More definitions related to parsing...</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">evalProgram</span><span class="punct">(</span><span class="name">program</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="comment">// More definitions related to evaluation...</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">interpret</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="comment">// Interpreter support code...</span><span class="line">


</span><span class="name">interpret</span><span class="punct">(</span><span class="string">`(debug (+ 1 2))`</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>Note in particular that our compiler hasn&#x27;t even touched the input we
supplied.</p><h3 id="An-analogy">An analogy</h3><p>Suppose Alice claims to be able to translate French commands into English.
However, each time you give her a command to translate, she just fills in this
template:</p><pre><code class="block code">Call my bilingual sister Marie at 555-1234.
Tell her you&#x27;re a friend of Alice and need a favor.
In particular, say that you need her to &quot;{{original-command}}&quot; as soon as
possible.</code></pre><p>Bob decides to test Alice with the command <em>apporte-moi un croissant</em>.</p><p>Alice <!-- -->“<!-- -->translates<!-- -->”<!-- --> this to:</p><pre><code class="block code">Call my bilingual sister Marie at 555-1234.
Tell her you&#x27;re a friend of Alice and need a favor.
In particular, say that you need her to &quot;apporte-moi un croissant&quot; as
soon as possible.</code></pre><p>Is this a valid translation?
It&#x27;s in English, and—more importantly—if Bob issues this command to someone who
only speaks English, he&#x27;ll end up with a croissant<a id="__footnote_ref_2" href="#__footnote_2" class="footnote-ref"><sup>2</sup></a>.</p><p>However, as in our compiler, <em>the original French phrase hasn&#x27;t been touched</em>.
Alice has simply bundled an <!-- -->“<!-- -->interpreter<!-- -->”<!-- --> (her sister) with the original French
phrase, along with enough plumbing to get the interpreter to execute the
command.
Our compiler is no different.</p><h2 id="So...is-this-a-compiler?">So...is this a compiler?</h2><p><a href="https://slatestarcodex.com/2014/11/21/the-categories-were-made-for-man-not-man-for-the-categories/">Sure, if you want it to be</a>.
What&#x27;s more interesting is what this means for our original definitions.
They&#x27;re short, sweet, and intellectually-pleasing.
We could even use them to draw some pretty diagrams.
But they admit pathological examples like the one we constructed here.
Practically-speaking this poses no problem: those definitions don&#x27;t really
matter when compiling or evaluating programs.
But it does raise an interesting question: can we devise a different pair of
definitions that excludes our compiler?
My gut tells me no, but I&#x27;ll think about this some more.</p><div id="__footnote_1" class="footnote"><a href="#__footnote_ref_1">1<!-- -->.</a><div class="footnote-content"><p>In this case, <code class="inline code">node</code> is our interpreter function <code class="inline code">i: JS -&gt; M</code>, and <code class="inline code">node
      not-a-compiler.js</code> is our compiler <code class="inline code">k: Scheme -&gt; JS</code>.</p></div></div><div id="__footnote_2" class="footnote"><a href="#__footnote_ref_2">2<!-- -->.</a><div class="footnote-content"><p>Marie will still need to infer or ask about some of the surrounding
            context (who does <!-- -->“<!-- -->moi<!-- -->”<!-- --> refer to?).
            Alice should really augment her template with an <!-- -->“<!-- -->initial
            environment<!-- -->”<!-- --> containing bindings for <!-- -->“<!-- -->global<!-- -->”<!-- --> identifiers, like</p><pre><code class="block code">moi -&gt; Bob
...</code></pre></div></div></main>
  
    <footer>
      <span>Created: 8/14/2023</span>
      <span>Last updated: 8/17/2023</span>
    </footer>
  </body>
</html>