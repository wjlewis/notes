<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="/notes/main.css" />
    <title>This is not a compiler</title>
  </head>

  <body>
    <main><h1>This is not a compiler</h1><p>What&#x27;s the difference between a compiler and an interpreter?
A compiler transforms a program in one language into an equivalent program in
another language, whereas an interpreter <span>“<!-- -->runs<!-- -->”</span> a program.</p><p>Let&#x27;s try to formalize this.
We&#x27;ll let <code class="inline">L_1</code> and <code class="inline">L_2</code> be sets containing all legal programs written in two
languages, and <code class="inline">M</code> be the set of all possible <span>“<!-- -->meanings<!-- -->”</span> a program might have.
Finally, for each language <code class="inline">L_n</code>, suppose we&#x27;ve got some function</p><pre><code>m_n : L_n -&gt; M</code></pre><p>that produces the meaning of any program in <code class="inline">L</code>.</p><p>Then an interpreter for language <code class="inline">L_1</code> is just a function</p><pre><code>i : L_1 -&gt; M</code></pre><p>that produces the right meaning for each program in <code class="inline">L</code>.
That is, for every <code class="inline">p</code> in <code class="inline">L_1</code>, <code class="inline">i(p) = m_1(p)</code>.
Likewise, a compiler from <code class="inline">L_1</code> to <code class="inline">L_2</code> is just a function <code class="inline">K : L_1 -&gt; L_2</code>
that translates any program in <code class="inline">L_1</code> into an <em>equivalent</em> program in <code class="inline">L_2</code>.
So, for every <code class="inline">p</code> in <code class="inline">L_1</code>, <code class="inline">m_1(p) = m_2(k(p))</code>.</p><p>We&#x27;ve arrived at two simple, pleasing definitions which reveal the distinction
between a compiler and interpreter.
But this isn&#x27;t the whole story, and that&#x27;s the point of this note.
For the remainder of our time, we&#x27;ll look at a pathological example that
<em>technically</em> satisfies the definition of a compiler while <em>morally</em> failing to
be one.
This has absolutely no practical significance, but it&#x27;s a neat exercise, and it
also serves as an interesting example of the difficulty (or futility) of trying
to pin down even seemingly well-behaved concepts.</p><h2>The big picture</h2><p>We&#x27;re going to write a program that <span>“<!-- -->compiles<!-- -->”</span> Scheme to JavaScript by simply
embedding a Scheme interpreter (written in JavaScript) along with the program we
asked it to compile.
Here&#x27;s the bird&#x27;s eye view:</p><pre><code><span class="comment">// Transform a Scheme program into an equivalent JavaScript program.</span><span class="line">
</span><span class="keyword">function</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">program</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="string">`
// Run the provided Scheme program, producing its meaning.
function interpret(program) {
  // ...
}

interpret(`</span><span class="unknown">$</span><span class="punct">{</span><span class="name">program</span><span class="punct">}</span><span class="string">`);
`</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Does this satisfy our formal definition above?
Is it a compiler?
We&#x27;ll return to these questions <a href="#Is this a compiler?">later</a>.
But first, let&#x27;s write this thing.</p><h2>A pocket-sized Scheme</h2><p>The bulk of our <code class="inline">compile</code> function is just a quoted Scheme interpreter, written
in JavaScript.
To keep the exercise interesting, the interpreter should at least be capable of
running a metacircular evaluator.
To keep it simple, we&#x27;ll forgo any of the bells and whistles that usually
accompany Scheme implementations (like a macro system, and even error messages).
The result is a <span>“<!-- -->pocket-sized<!-- -->”</span> Scheme that comes in under 200 lines.</p><p>First, let&#x27;s write a lexer that converts a string representation of a Scheme
program into <span>“<!-- -->tokens<!-- -->”</span>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">re</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="regex">/\(|\)|\[|\]|&#x27;|[a-z+*\-&lt;&gt;=!?]+|\d+|#(t|f)/</span><span class="name">g</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">parts</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">match</span><span class="punct">(</span><span class="name">re</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="comment">// Convert &#x27;#t&#x27; and &#x27;#f&#x27; into `true` and `false`, and numeric strings into</span><span class="line">
</span><span class="space">  </span><span class="comment">// numbers.</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">parts</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">part</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;#t&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;#f&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">part</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">part</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;#t&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="op">!</span><span class="name">isNaN</span><span class="punct">(</span><span class="name">part</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">Number</span><span class="punct">(</span><span class="name">part</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">part</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>The function <code class="inline">lex</code> first extracts all of the substrings from the source that
match the regular expression <code class="inline">re</code>.
The <code class="inline">g</code> flag causes
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code class="inline">match</code></a>
to return <em>all</em> matches.
We then <code class="inline">map</code> over the extracted parts, converting Scheme boolean and number
tokens into JavaScript booleans and numbers, which will make evaluation easier.</p><p>For example,</p><pre><code><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;(and #t (&gt; 2 1))&#x27;</span><span class="punct">)</span></code></pre><p>produces the array:</p><pre><code><span class="punct">[</span><span class="string">&#x27;(&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;and&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="keyword">true</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;(&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;&gt;&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">]</span></code></pre><p>Next, the dreaded parser.
We&#x27;ll write a classic recursive-descent parser that represents s-expressions
using JavaScript arrays.
We won&#x27;t handle dotted pairs, which simplifies both the parser and the rest of
the intepreter.</p><p>Here&#x27;s a grammar to guide our efforts:</p><pre><code>Program = Expr*
Expr = Name
     | Number
     | Boolean
     | &quot;(&quot; Expr* &quot;)&quot;
     | &quot;[&quot; Expr* &quot;]&quot;
     | &quot;&#x27;&quot; Expr</code></pre><p>We can translate this grammar into JavaScript by</p><ul><li><p>writing a <code class="inline">parseX</code> function for each nonterminal <code class="inline">X</code> (i.e. <code class="inline">parseProgram</code> and
 <code class="inline">parseExpr</code>)</p></li><li><p>replacing each <code class="inline">*</code> with an appropriate loop</p></li><li><p>replacing each reference to a nonterminal <code class="inline">X</code> on the righthand side with a
 (potentially recursive) call to the <code class="inline">parseX</code> function</p></li><li><p>just emit the token for terminals (i.e. names, numbers, and booleans)</p></li></ul><p>Working step-by-step, we write a <code class="inline">parseProgram</code> function to parse <code class="inline">Program</code>s:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseProgram</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">exprs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">tokens</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">&gt;</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">exprs</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">exprs</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Easy enough, but what about parsing <code class="inline">Expr</code>essions?</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;(&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;[&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">parseList</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">tokens</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&quot;&#x27;&quot;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">quoted</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;quote&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">quoted</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p><code class="inline">parseExpr</code> examines the first token.
If it&#x27;s an open parenthesis or bracket, it parses a <span>“<!-- -->list<!-- -->”</span> (see below); if it&#x27;s
a quote (<code class="inline">&#x27;</code>), it consumes the token, parses an expression (see the grammar),
and synthesizes an appropriate <code class="inline">(quote ...)</code> s-expression; and if its an atom
(name, number, or boolean), it simply consumes and returns the token.</p><p>That just leaves <code class="inline">parseList</code>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseList</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">opener</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">closers</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="string">&#x27;(&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;[&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;]&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="comment">// Determine if we&#x27;re looking for a &#x27;)&#x27; or &#x27;]&#x27;.</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">closer</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">closers</span><span class="punct">[</span><span class="name">opener</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">exprs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">tokens</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">&gt;</span><span class="space"> </span><span class="number">0</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">tokens</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">!</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">closer</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">exprs</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="comment">// Consume the closing token.</span><span class="line">
</span><span class="space">  </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">exprs</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Again, this just does what the grammar indicates.
(This implementation of <code class="inline">parseList</code> combines the nearly identical cases of
parenthesized <code class="inline">(...)</code> and bracketed <code class="inline">[...]</code> lists, but we could just as well
have written separate functions for each.)</p><p>If this is your first time writing a parser, I&#x27;d encourage you to add some
<code class="inline">console.log</code>s throughout these functions (or try an example on paper) to see
how they interact.</p><p>We can now parse programs into array-based abstract syntax trees.
For example:</p><pre><code><span class="name">parseProgram</span><span class="punct">(</span><span class="line">
</span><span class="space">  </span><span class="name">lex</span><span class="punct">(</span><span class="string">`
(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))

(map fact &#x27;(0 1 2 3 4 5))
`</span><span class="punct">)</span><span class="line">
</span><span class="punct">)</span></code></pre><p>produces</p><pre><code><span class="punct">[</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;define&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;fact&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;n&#x27;</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">]</span><span class="punct">]</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;map&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;fact&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;quote&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">]</span><span class="punct">]</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="punct">]</span></code></pre><p>With that, we&#x27;ve arrived at the main event: evaluation.</p><p>If you&#x27;ve written a metacircular evaluator in Scheme then this will look very
familiar.
If not, check out
<a href="https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book.html">SICP</a>
or <span>“<!-- -->The Little Schemer<!-- -->”</span>.
You won&#x27;t be disappointed.</p><p>To evaluate a program, we simply evaluate each expression in the program:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">evalProgram</span><span class="punct">(</span><span class="name">program</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">for</span><span class="space"> </span><span class="punct">(</span><span class="keyword">const</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="keyword">of</span><span class="space"> </span><span class="name">program</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>All of the action occurs in <code class="inline">evalExpr</code>, which performs a case analysis on the
<code class="inline">expr</code> we give it:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;number&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;boolean&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">expr</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Names</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Compound expressions (e.g. `(let ([x 2]) ...)`)</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Literals (numbers and booleans) evaluate to themselves.
That is, <code class="inline">evalExpr(42, &lt;anything&gt;)</code> produces <code class="inline">42</code>.</p><p>What about other expression types?
Let&#x27;s work through one case at a time.
The value of a name is just the value it&#x27;s bound to in the <code class="inline">env</code>rionment:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">lookup</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>We&#x27;ll represent environments as objects with a <code class="inline">bindings</code> field whose value is
an object associating names with values, and a <code class="inline">base</code> field that points to a
(possibly empty) environment.
To <code class="inline">lookup</code> the value bound to a name in an environment, we check if the name
occurs in the environment&#x27;s <code class="inline">bindings</code>; if not, we recursively check the <code class="inline">base</code>
environment:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lookup</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">name</span><span class="space"> </span><span class="keyword">in</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">env</span><span class="op">.</span><span class="name">base</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">lookup</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">base</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">`unbound name: </span><span class="op">${</span><span class="name">name</span><span class="op">}</span><span class="string">`</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>As always, let&#x27;s try an example.
Suppose</p><pre><code><span class="keyword">const</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">bindings</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">a</span><span class="op">:</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="name">b</span><span class="op">:</span><span class="space"> </span><span class="number">2</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">base</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">bindings</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">a</span><span class="op">:</span><span class="space"> </span><span class="number">42</span><span class="punct">,</span><span class="space"> </span><span class="name">c</span><span class="op">:</span><span class="space"> </span><span class="keyword">true</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="punct">}</span><span class="punct">;</span></code></pre><p>Then <code class="inline">lookup(&#x27;a&#x27;, env)</code> produces <code class="inline">1</code>, <code class="inline">lookup(&#x27;b&#x27;, env)</code> is <code class="inline">2</code>, <code class="inline">lookup(&#x27;c&#x27;,
env)</code> is <code class="inline">true</code>, and <code class="inline">lookup(&#x27;quux&#x27;, env)</code> throws an error.</p><p>Returning to <code class="inline">evalExpr</code>, all that remains are compound expressions, which we&#x27;ve
represented as arrays.
We decide what to do based on the first element.
For example, if the expression begins with <code class="inline">[&#x27;if&#x27;, ...]</code>, we evaluate either
the true <span>“<!-- -->arm<!-- -->”</span> or false arm according to the value of the test expression.</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">first</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rest</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;if&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">trueExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">falseExpr</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">isTrue</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">isTrue</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">trueExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">falseExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// ...</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p><code class="inline">lambda</code> expressions evaluate to closures, which we represent as objects
containing the lambda&#x27;s parameters, body, and current environment:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;lambda&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p><code class="inline">quote</code> expressions simply return the quoted expression <em>as a value</em>:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;quote&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">rest</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>We <span>“<!-- -->desugar<!-- -->”</span> <code class="inline">let</code> expressions into equivalent applications of <code class="inline">lambda</code>
expressions.
For example,</p><pre><code>(let ([x 1] [y 2])
  (+ x y))</code></pre><p>becomes</p><pre><code>((lambda (x y)
   (+ x y))
 1 2)</code></pre><p>We could just as well <span>“<!-- -->directly<!-- -->”</span> evaluate <code class="inline">let</code> expressions, but this lets us
keep the core of the evaluator smaller.</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;let&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">desugarLet</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>where</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">desugarLet</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">_let</span><span class="punct">,</span><span class="space"> </span><span class="name">bindings</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">params</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">bindings</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="punct">(</span><span class="punct">[</span><span class="name">param</span><span class="punct">,</span><span class="space"> </span><span class="name">_rand</span><span class="punct">]</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">param</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">rands</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">bindings</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="punct">(</span><span class="punct">[</span><span class="name">_param</span><span class="punct">,</span><span class="space"> </span><span class="name">rand</span><span class="punct">]</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">rand</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">lambda</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;lambda&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="name">lambda</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rands</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Try it out!</p><p>Likewise, <code class="inline">cond</code> gets desugared into a sequence of <code class="inline">if</code>s:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;cond&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">desugarCond</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>where</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">desugarCond</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">_cond</span><span class="punct">,</span><span class="space"> </span><span class="name">clauses</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">clauses</span><span class="op">.</span><span class="name">reduceRight</span><span class="punct">(</span><span class="line">
</span><span class="space">    </span><span class="punct">(</span><span class="name">falseExpr</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">trueExpr</span><span class="punct">]</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">trueExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">falseExpr</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="number">0</span><span class="line">
</span><span class="space">  </span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Try it!</p><pre><code><span class="name">desugarCond</span><span class="punct">(</span><span class="line">
</span><span class="space">  </span><span class="name">parseExpr</span><span class="punct">(</span><span class="line">
</span><span class="space">    </span><span class="name">lex</span><span class="punct">(</span><span class="string">`
(cond [(= n 1) 1]
      [(= n 2) 42]
      [#t      123])
`</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="punct">)</span><span class="line">
</span><span class="punct">)</span></code></pre><p>produces</p><pre><code><span class="punct">[</span><span class="line">
</span><span class="space">  </span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;=&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;n&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="number">1</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;=&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;n&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="number">42</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="keyword">true</span><span class="punct">,</span><span class="space"> </span><span class="number">123</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">]</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="punct">]</span></code></pre><p>Definitions add a binding for the defined name, <em>mutating</em> the current
environment:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;define&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">isDefiningName</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">rest</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">isDefiningName</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rhs</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="punct">[</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">params</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">lambda</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;lambda&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">lambda</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>Here we support defining both names <em>and</em> functions:</p><pre><code>(define quux 42)

(define (square x)
  (* x x))</code></pre><p>Finally, applications:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">rator</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rands</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rator</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">args</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rands</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">rand</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rand</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;function&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">op</span><span class="punct">(</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">args</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="punct">}</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">op</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">bindings</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">Object</span><span class="op">.</span><span class="name">fromEntries</span><span class="punct">(</span><span class="name">zip</span><span class="punct">(</span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">args</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">env1</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">bindings</span><span class="punct">,</span><span class="space"> </span><span class="name">base</span><span class="op">:</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">env1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>We&#x27;ll include some primitives (like <code class="inline">+</code>, <code class="inline">cons</code>, etc.) as JavaScript functions,
which is why we need to check the operator&#x27;s type.
If the operator is a JavaScript function, we simply apply it to the arguments;
if it&#x27;s a closure we do the usual thing: extend the environment by binding the
closure&#x27;s parameters to the arguments, and evaluate the body in this new
extended environment.</p><p>Constructing the new bindings is a simple matter of <code class="inline">zip</code>ping the names and args
together, and turning the resulting array into an object.</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">zip</span><span class="punct">(</span><span class="name">xs</span><span class="punct">,</span><span class="space"> </span><span class="name">ys</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="punct">(</span><span class="name">x</span><span class="punct">,</span><span class="space"> </span><span class="name">i</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">[</span><span class="name">x</span><span class="punct">,</span><span class="space"> </span><span class="name">ys</span><span class="punct">[</span><span class="name">i</span><span class="punct">]</span><span class="punct">]</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>We&#x27;re now ready to define <code class="inline">interpret</code>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">interpret</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">env0</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">bindings</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;+&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;-&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">-</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;*&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">*</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;&lt;&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">&lt;</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;=&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;number?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;number&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;boolean?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;boolean&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;symbol?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;eq?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;empty?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">xs</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">cons</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">head</span><span class="punct">,</span><span class="space"> </span><span class="name">tail</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">[</span><span class="name">head</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">tail</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">head</span><span class="op">:</span><span class="space"> </span><span class="name">xs</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">xs</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">tail</span><span class="op">:</span><span class="space"> </span><span class="name">xs</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">slice</span><span class="punct">(</span><span class="number">1</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">debug</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">console</span><span class="op">.</span><span class="name">log</span><span class="punct">(</span><span class="name">showValue</span><span class="punct">(</span><span class="name">v</span><span class="punct">)</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="name">evalProgram</span><span class="punct">(</span><span class="name">parseProgram</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">env0</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p><code class="inline">interpret</code> just glues all of the pieces together and provides a few primitives
for working with numbers and lists.
We also include a <code class="inline">debug</code> primitive for printing to the console, which relies on
<code class="inline">showValue</code>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">showValue</span><span class="punct">(</span><span class="name">v</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">Array</span><span class="op">.</span><span class="name">isArray</span><span class="punct">(</span><span class="name">v</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="string">`(</span><span class="op">${</span><span class="name">v</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">showValue</span><span class="punct">)</span><span class="op">.</span><span class="name">join</span><span class="punct">(</span><span class="string">&#x27; &#x27;</span><span class="punct">)</span><span class="op">}</span><span class="string">)`</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;object&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="string">&#x27;#&lt;closure&gt;&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">v</span><span class="op">.</span><span class="name">toString</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Let&#x27;s give this baby a whirl:</p><pre><code><span class="name">interpret</span><span class="punct">(</span><span class="string">`
(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))

(define (map fn xs)
  (if (empty? xs)
      &#x27;()
      (cons (fn (head xs))
            (map fn (tail xs)))))

(define quux (map fact &#x27;(0 1 2 3 4 5)))

(debug quux)
`</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="comment">// =&gt; (1 1 2 6 24 120)</span></code></pre><h2>The compiler, finally</h2><p>If you perservered through the previous section, I applaud you.
Time for the payoff.
All that&#x27;s left is to write <code class="inline">compile</code>, which simply interpolates the provided
program into a template containing the interpreter code we just wrote.</p><p>Since we&#x27;re going to paste the interpreter source code inside a template string,
we need to be careful to escape all backticks (<code class="inline">`</code>); we also need to escape
dollar signs (<code class="inline">$</code>) and escape characters (<code class="inline">\</code>) as well.
This is easy enough to do manually, but we can also automate it with a little
script.</p><p>If the following is saved in a file named <em>quote.js</em>:</p><pre><code><span class="name">process</span><span class="op">.</span><span class="name">stdin</span><span class="line">
</span><span class="space">  </span><span class="op">.</span><span class="name">setEncoding</span><span class="punct">(</span><span class="string">&#x27;utf-8&#x27;</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="comment">// Replace backticks (`), dollar signs ($), and escape characters (\) with an</span><span class="line">
</span><span class="space">  </span><span class="comment">// escaped version, e.g. $ -&gt; \$.</span><span class="line">
</span><span class="space">  </span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">chunk</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">chunk</span><span class="op">.</span><span class="name">replace</span><span class="punct">(</span><span class="op">/</span><span class="string">`|\$|\/g, c =&gt; `</span><span class="unknown">\</span><span class="unknown">$</span><span class="punct">{</span><span class="name">c</span><span class="punct">}</span></code></pre><p>and the interpreter source is saved in <em>pocket-scheme.js</em>, then</p><pre><code>$ node quote.js &lt; pocket-scheme.js &gt; quoted-interpreter.txt</code></pre><p>will save the quoted interpreter source in <em>quoted-interpreter.txt</em>.</p><p>In a new file (which I&#x27;m calling <em>not-a-compiler.js</em>), copy the quoted
interpreter source into the body of a function named <code class="inline">compile</code>, along with a
(quoted) invocation of the <code class="inline">interpret</code> function on the <code class="inline">source</code> of the program
to be <span>“<!-- -->compiled<!-- -->”</span>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">interpreterSource</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="string">`
function lex(source) {
  const re = /\(|\)|\[|\]|&#x27;|[a-z+*\-&lt;&gt;=!?]+|\d+|#(t|f)/g;
  const parts = source.match(re);
...
`</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="string">`
</span><span class="op">${</span><span class="name">interpreterSource</span><span class="op">}</span><span class="string">

interpret(`</span><span class="unknown">$</span><span class="punct">{</span><span class="name">source</span><span class="punct">}</span><span class="string">`);
`</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p><em>The full listing is available <a href="https://gist.github.com/wjlewis/a85a5b9a66875d82c1155a59474aee7d">here</a>.</em></p><p>Finally, to make our <span>“<!-- -->compiler<!-- -->”</span> a little more ergonomic, let&#x27;s read input
programs from <code class="inline">stdin</code> and write our compiled output to <code class="inline">stdout</code>:</p><pre><code><span class="keyword">const</span><span class="space"> </span><span class="name">fs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">require</span><span class="punct">(</span><span class="string">&#x27;fs&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">const</span><span class="space"> </span><span class="name">source</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">fs</span><span class="op">.</span><span class="name">readFileSync</span><span class="punct">(</span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;utf-8&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="name">fs</span><span class="op">.</span><span class="name">writeFileSync</span><span class="punct">(</span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>We can now compile Scheme files by executing</p><pre><code>$ node not-a-compiler.js &lt; my-program.scm</code></pre><p>and compile-and-execute via</p><pre><code>$ node not-a-compiler.js &lt; my-program.scm | node</code></pre><p>or compose on-the-fly with</p><pre><code>$ node not-a-compiler.js | node
(define (fib n)
  (cond [(= n 1) 1]
        [(= n 2) 1]
        [#t      (+ (fib (- n 1))
                    (fib (- n 2)))]))

(debug (fib 10))
Ctrl+D
55</code></pre><h2>Is this a compiler?</h2><p>Yes, according to our definition above.
It transforms Scheme programs into equivalent JavaScript programs, in the sense
that</p><pre><code>$ scheme my-program.scm</code></pre><p>and</p><pre><code>$ node not-a-compiler.js &lt; my-program.scm &gt; my-program.js
$ node my-program.js</code></pre><p>produce the same result.</p><p>But it doesn&#x27;t actually <em>do</em> anything.
It just packages an interpreter alongside the program we gave it and says <span>“<!-- -->run
this later<!-- -->”</span>.
A compiler should <span>“<!-- -->know something<!-- -->”</span> about the two languages it works with, and
<code class="inline">compile</code> doesn&#x27;t really know anything about JavaScript.</p><p>To put this into more familiar terms, suppose I told you that I could translate
French imperative statements into English.
To test my abilities, you write a French command, say</p><pre><code>passe-moi le sel</code></pre><p>on a slip of paper, and hand it to me.
On the back of the slip, I write</p><pre><code>The following is a command written in French:

    passe-moi le sel

Call my friend Jacques at (864) 555-8729.
Ask him to tell you what it means, and then do whatever he says.</code></pre><p>As always, let&#x27;s try this out.
You and I are eating dinner with a French friend, and I say to our guest,
<span>“<!-- -->passe-moi le sel<!-- -->”</span>.
Sure enough, he passes me the salt.
Now I want to ask you to do the same, but you only speak English.
Do I ask you to <span>“<!-- -->please pass the salt<!-- -->”</span>?
No; I pass you this card, and</p><ol><li><p>You call Jacques and ask him, <span>“<!-- -->What does &#x27;passe-moi le sel&#x27; mean?<!-- -->”</span></p></li><li><p>He says, <span>“<!-- -->It means &#x27;pass the salt&#x27;<!-- -->”</span></p></li><li><p>You pass me the salt</p></li></ol><p>This <em>works</em> in the sense that it allows people who only speak English to carry
out orders written in French.
But I haven&#x27;t translated anything here.
I&#x27;ve just deferred the work until <span>“<!-- -->runtime<!-- -->”</span>, leaning on my friend (and
<span>“<!-- -->interpreter<!-- -->”</span>) Jacques.</p><p><em>This result has absolutely no practical consequences</em>, but it does punch a hole
through a pair of otherwise nice definitions.
I&#x27;m perenially interested in the ways that concepts break down or <span>“<!-- -->blur<!-- -->”</span>.
This is yet another example, but in a somewhat surprising context.
Can we patch up these definitions so that they <span>“<!-- -->correctly<!-- -->”</span> categorize our
<code class="inline">compile</code> function as ... something else?
It seems unlikely, but I&#x27;ll continue to think on this.</p></main>
  </body>
</html>