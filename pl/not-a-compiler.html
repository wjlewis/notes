<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="/notes/main.css" />
    <title>This is not a compiler</title>
  </head>

  <body>
    <main><h1 id="This-is-not-a-compiler">This is not a compiler</h1><p>What&#x27;s the difference between a compiler and an interpreter?
A compiler transforms a program in one language into an equivalent program in
another language, whereas an interpreter <!-- -->“<!-- -->runs<!-- -->”<!-- --> a program.</p><p>Let&#x27;s try to formalize this.
We&#x27;ll let <code class="inline">L_1</code> and <code class="inline">L_2</code> be sets containing all legal programs written in two
languages, and <code class="inline">M</code> be the set of all possible <!-- -->“<!-- -->meanings<!-- -->”<!-- --> a program might have.
Finally, for each language <code class="inline">L_n</code>, suppose we&#x27;ve got some function</p><pre><code>m_n : L_n -&gt; M</code></pre><p>that produces the meaning of any program in <code class="inline">L</code>.</p><p>Then an interpreter for language <code class="inline">L_1</code> is just a function</p><pre><code>i : L_1 -&gt; M</code></pre><p>that produces the right meaning for each program in <code class="inline">L</code>.
That is,</p><blockquote><p>for every <code class="inline">p</code> in <code class="inline">L_1</code>, <code class="inline">i(p) = m_1(p)</code>.</p></blockquote><p>Likewise, a compiler from <code class="inline">L_1</code> to <code class="inline">L_2</code> is just a function <code class="inline">k : L_1 -&gt; L_2</code>
that translates any program in <code class="inline">L_1</code> into an <em>equivalent</em> program in <code class="inline">L_2</code>.
So,</p><blockquote><p>for every <code class="inline">p</code> in <code class="inline">L_1</code>, <code class="inline">m_1(p) = m_2(k(p))</code>.</p></blockquote><p>The slogan: is <em>interpreters reveal meaning; compilers preserve meaning</em>.</p><p>We&#x27;ve arrived at two simple, pleasing definitions which reveal the distinction
between a compiler and interpreter.
But this isn&#x27;t the whole story, and that&#x27;s the point of this note.
For the remainder of our time, we&#x27;ll look at a pathological example that
<em>technically</em> satisfies this definition of a compiler while <em>morally</em> failing to
be one.
This has absolutely no practical significance, but it&#x27;s a neat exercise, and it
also serves as an interesting example of the difficulty (or futility) of trying
to pin down even seemingly well-behaved concepts.</p><h2 id="The-big-picture">The big picture</h2><p>We&#x27;re going to write a program that <!-- -->“<!-- -->compiles<!-- -->”<!-- --> Scheme to JavaScript by simply
embedding a Scheme interpreter (written in JavaScript) along with the program we
asked it to compile.
Here&#x27;s the bird&#x27;s eye view:</p><pre><code><span class="comment">// Transform a Scheme program into an equivalent JavaScript program by bundling</span><span class="line">
</span><span class="comment">// an interpreter with the original program.</span><span class="line">
</span><span class="keyword">function</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">program</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="string">`
// Run the provided Scheme program, producing its meaning.
function interpret(program) {
  // ...
}

interpret(\`</span><span class="op">${</span><span class="name">program</span><span class="op">}</span><span class="string">\`);
`</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Does this satisfy our formal definition above?
Is it a compiler?
We&#x27;ll return to these questions later.
But first, let&#x27;s write this thing.</p><h2 id="A-pocket-sized-Scheme">A pocket-sized Scheme</h2><p>The bulk of our <code class="inline">compile</code> function is just a quoted Scheme interpreter, written
in JavaScript.
To keep the exercise interesting, the interpreter should at least be capable of
running a metacircular evaluator.
To keep it simple, we&#x27;ll forgo any of the bells and whistles that usually
accompany Scheme implementations (like a macro system, and even error messages).
The result is a <!-- -->“<!-- -->pocket-sized<!-- -->”<!-- --> Scheme that comes in under 200 lines.</p><p>First, let&#x27;s write a lexer that converts a string representation of a Scheme
program into <!-- -->“<!-- -->tokens<!-- -->”<!-- -->:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">re</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="regex">/\(|\)|\[|\]|&#x27;|[a-z+*\-&lt;&gt;=!?]+|\d+|#(t|f)/</span><span class="name">g</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">parts</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">source</span><span class="op">.</span><span class="name">match</span><span class="punct">(</span><span class="name">re</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="comment">// Convert &#x27;#t&#x27; and &#x27;#f&#x27; into `true` and `false`, and numeric strings into</span><span class="line">
</span><span class="space">  </span><span class="comment">// numbers.</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">parts</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">part</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;#t&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;#f&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">part</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">part</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;#t&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="op">!</span><span class="name">isNaN</span><span class="punct">(</span><span class="name">part</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">Number</span><span class="punct">(</span><span class="name">part</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">part</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>The function <code class="inline">lex</code> first extracts all of the substrings from the source that
match the regular expression <code class="inline">re</code>.
The <code class="inline">g</code> flag causes
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code class="inline">match</code></a>
to return <em>all</em> matches.
We then <code class="inline">map</code> over the extracted parts, converting Scheme boolean and number
tokens into JavaScript booleans and numbers, which will make evaluation easier.</p><p>For example,</p><pre><code><span class="name">lex</span><span class="punct">(</span><span class="string">&#x27;(and #t (&gt; 2 1))&#x27;</span><span class="punct">)</span></code></pre><p>produces the array:</p><pre><code><span class="punct">[</span><span class="string">&#x27;(&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;and&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="keyword">true</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;(&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;&gt;&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">]</span></code></pre><p>Next, the dreaded parser.
We&#x27;ll write a classic recursive-descent parser that represents s-expressions
using JavaScript arrays.
We won&#x27;t handle dotted pairs, which simplifies both the parser and the rest of
the intepreter.</p><p>Here&#x27;s a grammar to guide our efforts:</p><pre><code>Program = Expr*
Expr = Name
     | Number
     | Boolean
     | &quot;(&quot; Expr* &quot;)&quot;
     | &quot;[&quot; Expr* &quot;]&quot;
     | &quot;&#x27;&quot; Expr</code></pre><p>We can translate this grammar into JavaScript by</p><ul><li><p>writing a <code class="inline">parseX</code> function for each nonterminal <code class="inline">X</code> (i.e. <code class="inline">parseProgram</code> and
 <code class="inline">parseExpr</code>)</p></li><li><p>replacing each <code class="inline">*</code> with an appropriate loop</p></li><li><p>replacing each reference to a nonterminal <code class="inline">X</code> on the righthand side with a
 (potentially recursive) call to the <code class="inline">parseX</code> function</p></li><li><p>just emit the token for terminals (i.e. names, numbers, and booleans)</p></li></ul><p>Working step-by-step, we write a <code class="inline">parseProgram</code> function to parse <code class="inline">Program</code>s:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseProgram</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">exprs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">tokens</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">&gt;</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">exprs</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">exprs</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Easy enough, but what about parsing <code class="inline">Expr</code>essions?</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;(&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;[&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">parseList</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">tokens</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&quot;&#x27;&quot;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">quoted</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;quote&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">quoted</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p><code class="inline">parseExpr</code> examines the first token.
If it&#x27;s an open parenthesis or bracket, it parses a <!-- -->“<!-- -->list<!-- -->”<!-- --> (see below); if it&#x27;s
a quote (<code class="inline">&#x27;</code>), it consumes the token, parses an expression (see the grammar),
and synthesizes an appropriate <code class="inline">(quote ...)</code> s-expression; and if it&#x27;s an atom
(name, number, or boolean), it simply consumes and returns the token.</p><p>That just leaves <code class="inline">parseList</code>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">parseList</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">opener</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">closers</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="string">&#x27;(&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;)&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;[&#x27;</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;]&#x27;</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="comment">// Determine if we&#x27;re looking for a &#x27;)&#x27; or &#x27;]&#x27;.</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">closer</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">closers</span><span class="punct">[</span><span class="name">opener</span><span class="punct">]</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">exprs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="name">tokens</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">&gt;</span><span class="space"> </span><span class="number">0</span><span class="space"> </span><span class="op">&amp;</span><span class="op">&amp;</span><span class="space"> </span><span class="name">tokens</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">!</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">closer</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">exprs</span><span class="op">.</span><span class="name">push</span><span class="punct">(</span><span class="name">parseExpr</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="comment">// Consume the closing token.</span><span class="line">
</span><span class="space">  </span><span class="name">tokens</span><span class="op">.</span><span class="name">shift</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">exprs</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Again, this just does what the grammar indicates.
(This implementation of <code class="inline">parseList</code> combines the nearly identical cases of
parenthesized <code class="inline">(...)</code> and bracketed <code class="inline">[...]</code> lists, but we could just as well
have written separate functions for each.)</p><p>We can now parse programs into array-based abstract syntax trees.
For example:</p><pre><code><span class="name">parseProgram</span><span class="punct">(</span><span class="line">
</span><span class="space">  </span><span class="name">lex</span><span class="punct">(</span><span class="string">`
(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))

(map fact &#x27;(0 1 2 3 4 5))
`</span><span class="punct">)</span><span class="line">
</span><span class="punct">)</span></code></pre><p>produces</p><pre><code><span class="punct">[</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;define&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;fact&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;n&#x27;</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">]</span><span class="punct">]</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;map&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;fact&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;quote&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">]</span><span class="punct">]</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="punct">]</span></code></pre><p>With that, we&#x27;ve arrived at the main event: evaluation.</p><p>To evaluate a program, we simply evaluate each expression in the program:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">evalProgram</span><span class="punct">(</span><span class="name">program</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">for</span><span class="space"> </span><span class="punct">(</span><span class="keyword">const</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="keyword">of</span><span class="space"> </span><span class="name">program</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>All of the action occurs in <code class="inline">evalExpr</code>, which performs a case analysis on the
<code class="inline">expr</code> we give it:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="string">&#x27;number&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;boolean&#x27;</span><span class="punct">]</span><span class="op">.</span><span class="name">includes</span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">expr</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Names</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Compound expressions (e.g. `(let ([x 2]) ...)`)</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Literals (numbers and booleans) evaluate to themselves.
That is, <code class="inline">evalExpr(42, &lt;anything&gt;)</code> produces <code class="inline">42</code>.</p><p>What about other expression types?
Let&#x27;s work through one case at a time.
The value of a name is just the value it&#x27;s bound to in the <code class="inline">env</code>rionment:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">lookup</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>We&#x27;ll represent environments as objects with a <code class="inline">bindings</code> field whose value is
an object associating names with values, and a <code class="inline">base</code> field that points to a
(possibly empty) environment.
To <code class="inline">lookup</code> the value bound to a name in an environment, we check if the name
occurs in the environment&#x27;s <code class="inline">bindings</code>; if not, we recursively check the <code class="inline">base</code>
environment:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lookup</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">name</span><span class="space"> </span><span class="keyword">in</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">env</span><span class="op">.</span><span class="name">base</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">lookup</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">base</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">`unbound name: </span><span class="op">${</span><span class="name">name</span><span class="op">}</span><span class="string">`</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>As always, let&#x27;s try an example.
Suppose</p><pre><code><span class="keyword">const</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="name">bindings</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">a</span><span class="op">:</span><span class="space"> </span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="name">b</span><span class="op">:</span><span class="space"> </span><span class="number">2</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="name">base</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">bindings</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">a</span><span class="op">:</span><span class="space"> </span><span class="number">42</span><span class="punct">,</span><span class="space"> </span><span class="name">c</span><span class="op">:</span><span class="space"> </span><span class="keyword">true</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="punct">}</span><span class="punct">;</span></code></pre><p>Then <code class="inline">lookup(&#x27;a&#x27;, env)</code> produces <code class="inline">1</code>, <code class="inline">lookup(&#x27;b&#x27;, env)</code> is <code class="inline">2</code>, <code class="inline">lookup(&#x27;c&#x27;,
env)</code> is <code class="inline">true</code>, and <code class="inline">lookup(&#x27;quux&#x27;, env)</code> throws an error.</p><p>Returning to <code class="inline">evalExpr</code>, all that remains are compound expressions, which we&#x27;ve
represented as arrays.
We decide what to do based on the first element.
For example, if the expression begins with <code class="inline">[&#x27;if&#x27;, ...]</code>, we evaluate either
the true <!-- -->“<!-- -->arm<!-- -->”<!-- --> or false arm according to the value of the test expression.</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">first</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rest</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;if&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">trueExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">falseExpr</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">isTrue</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">isTrue</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">trueExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">falseExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// ...</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p><code class="inline">lambda</code> expressions evaluate to closures, which we represent as objects
containing the lambda&#x27;s parameters, body, and current environment:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;lambda&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p><code class="inline">quote</code> expressions simply return the quoted expression <em>as a value</em>:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;quote&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">rest</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>We <!-- -->“<!-- -->desugar<!-- -->”<!-- --> <code class="inline">let</code> expressions into equivalent applications of <code class="inline">lambda</code>
expressions.
For example,</p><pre><code><span class="punct">(</span><span class="keyword">let</span><span class="space"> </span><span class="punct">(</span><span class="punct">[</span><span class="name">x</span><span class="space"> </span><span class="number">1</span><span class="punct">]</span><span class="space"> </span><span class="punct">[</span><span class="name">y</span><span class="space"> </span><span class="number">2</span><span class="punct">]</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="punct">(</span><span class="name">+</span><span class="space"> </span><span class="name">x</span><span class="space"> </span><span class="name">y</span><span class="punct">)</span><span class="punct">)</span></code></pre><p>becomes</p><pre><code><span class="punct">(</span><span class="punct">(</span><span class="keyword">lambda</span><span class="space"> </span><span class="punct">(</span><span class="name">x</span><span class="space"> </span><span class="name">y</span><span class="punct">)</span><span class="line">
</span><span class="space">   </span><span class="punct">(</span><span class="name">+</span><span class="space"> </span><span class="name">x</span><span class="space"> </span><span class="name">y</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="space"> </span><span class="number">1</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span></code></pre><p>We could just as well <!-- -->“<!-- -->directly<!-- -->”<!-- --> evaluate <code class="inline">let</code> expressions, but this lets us
keep the core of the evaluator smaller.</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;let&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">desugarLet</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>where</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">desugarLet</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">_let</span><span class="punct">,</span><span class="space"> </span><span class="name">bindings</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">params</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">bindings</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="punct">(</span><span class="punct">[</span><span class="name">param</span><span class="punct">,</span><span class="space"> </span><span class="name">_rand</span><span class="punct">]</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">param</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">rands</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">bindings</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="punct">(</span><span class="punct">[</span><span class="name">_param</span><span class="punct">,</span><span class="space"> </span><span class="name">rand</span><span class="punct">]</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">rand</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">lambda</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;lambda&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="name">lambda</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rands</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Try it out!</p><p>Assignments <em>mutate</em> a binding in the current environment:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;set!&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">value</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rhs</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="name">assign</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">value</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">value</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>where</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">assign</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">value</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">name</span><span class="space"> </span><span class="keyword">in</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">value</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">env</span><span class="op">.</span><span class="name">base</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">assign</span><span class="punct">(</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">value</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="op">.</span><span class="name">base</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">throw</span><span class="space"> </span><span class="keyword">new</span><span class="space"> </span><span class="name">Error</span><span class="punct">(</span><span class="string">`unbound name: </span><span class="op">${</span><span class="name">name</span><span class="op">}</span><span class="string">`</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Likewise, <code class="inline">cond</code> gets desugared into a sequence of <code class="inline">if</code>s:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;cond&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">desugarCond</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>where</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">desugarCond</span><span class="punct">(</span><span class="name">expr</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">_cond</span><span class="punct">,</span><span class="space"> </span><span class="name">clauses</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">clauses</span><span class="op">.</span><span class="name">reduceRight</span><span class="punct">(</span><span class="line">
</span><span class="space">    </span><span class="punct">(</span><span class="name">falseExpr</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">trueExpr</span><span class="punct">]</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">testExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">trueExpr</span><span class="punct">,</span><span class="space"> </span><span class="name">falseExpr</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="number">0</span><span class="line">
</span><span class="space">  </span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Try it!</p><pre><code><span class="name">desugarCond</span><span class="punct">(</span><span class="line">
</span><span class="space">  </span><span class="name">parseExpr</span><span class="punct">(</span><span class="line">
</span><span class="space">    </span><span class="name">lex</span><span class="punct">(</span><span class="string">`
(cond [(= n 1) 1]
      [(= n 2) 42]
      [#t      123])
`</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="punct">)</span><span class="line">
</span><span class="punct">)</span></code></pre><p>produces</p><pre><code><span class="punct">[</span><span class="line">
</span><span class="space">  </span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;=&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;n&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="number">1</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;=&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;n&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="number">2</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="number">42</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;if&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="keyword">true</span><span class="punct">,</span><span class="space"> </span><span class="number">123</span><span class="punct">,</span><span class="space"> </span><span class="number">0</span><span class="punct">]</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="punct">]</span></code></pre><p>Definitions add a binding for the defined name, <em>mutating</em> the current
environment:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;define&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">isDefiningName</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">rest</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">isDefiningName</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="name">rhs</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rhs</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="punct">[</span><span class="name">name</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">params</span><span class="punct">]</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">lambda</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="string">&#x27;lambda&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">env</span><span class="op">.</span><span class="name">bindings</span><span class="punct">[</span><span class="name">name</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">lambda</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>Here we support defining both names <em>and</em> functions:</p><pre><code><span class="punct">(</span><span class="keyword">define</span><span class="space"> </span><span class="name">quux</span><span class="space"> </span><span class="number">42</span><span class="punct">)</span><span class="line">

</span><span class="punct">(</span><span class="keyword">define</span><span class="space"> </span><span class="punct">(</span><span class="name">square</span><span class="space"> </span><span class="name">x</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="punct">(</span><span class="name">*</span><span class="space"> </span><span class="name">x</span><span class="space"> </span><span class="name">x</span><span class="punct">)</span><span class="punct">)</span></code></pre><p>Sequences are evaluated by evaluating each expression in order.
The value of a sequence is the value of the final expression:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">first</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;begin&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">init</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="op">.</span><span class="name">slice</span><span class="punct">(</span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="op">-</span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">last</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rest</span><span class="punct">[</span><span class="name">rest</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">-</span><span class="space"> </span><span class="number">1</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">for</span><span class="space"> </span><span class="punct">(</span><span class="keyword">const</span><span class="space"> </span><span class="name">expr</span><span class="space"> </span><span class="keyword">of</span><span class="space"> </span><span class="name">init</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">last</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>All that remains are applications:</p><pre><code><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">rator</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">rands</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">expr</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rator</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">args</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">rands</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">rand</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">rand</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;function&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">op</span><span class="punct">(</span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">args</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="punct">}</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">op</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">bindings</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">Object</span><span class="op">.</span><span class="name">fromEntries</span><span class="punct">(</span><span class="name">zip</span><span class="punct">(</span><span class="name">params</span><span class="punct">,</span><span class="space"> </span><span class="name">args</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">env1</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">bindings</span><span class="punct">,</span><span class="space"> </span><span class="name">base</span><span class="op">:</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">env1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>We&#x27;ll include some primitives (like <code class="inline">+</code>, <code class="inline">cons</code>, etc.) as JavaScript functions,
which is why we need to check the operator&#x27;s type.
If the operator is a JavaScript function, we simply apply it to the arguments;
if it&#x27;s a closure we do the usual thing: extend the environment by binding the
closure&#x27;s parameters to the arguments, and evaluate the body in this new
extended environment.</p><p>Constructing the new bindings is a simple matter of <code class="inline">zip</code>ping the names and args
together, and turning the resulting array into an object.</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">zip</span><span class="punct">(</span><span class="name">xs</span><span class="punct">,</span><span class="space"> </span><span class="name">ys</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="punct">(</span><span class="name">x</span><span class="punct">,</span><span class="space"> </span><span class="name">i</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">[</span><span class="name">x</span><span class="punct">,</span><span class="space"> </span><span class="name">ys</span><span class="punct">[</span><span class="name">i</span><span class="punct">]</span><span class="punct">]</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>We&#x27;re now ready to define <code class="inline">interpret</code>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">interpret</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">env0</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="name">bindings</span><span class="op">:</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;+&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;-&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">-</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;*&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">*</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;&lt;&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">&lt;</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;=&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;number?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;number&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;boolean?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;boolean&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;symbol?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;string&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;eq?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">l</span><span class="punct">,</span><span class="space"> </span><span class="name">r</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">l</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">r</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="string">&#x27;empty?&#x27;</span><span class="op">:</span><span class="space"> </span><span class="name">xs</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">length</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">cons</span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">head</span><span class="punct">,</span><span class="space"> </span><span class="name">tail</span><span class="punct">)</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="punct">[</span><span class="name">head</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">tail</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">head</span><span class="op">:</span><span class="space"> </span><span class="name">xs</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">xs</span><span class="punct">[</span><span class="number">0</span><span class="punct">]</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">tail</span><span class="op">:</span><span class="space"> </span><span class="name">xs</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">xs</span><span class="op">.</span><span class="name">slice</span><span class="punct">(</span><span class="number">1</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">debug</span><span class="op">:</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">console</span><span class="op">.</span><span class="name">log</span><span class="punct">(</span><span class="name">showValue</span><span class="punct">(</span><span class="name">v</span><span class="punct">)</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">,</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="name">evalProgram</span><span class="punct">(</span><span class="name">parseProgram</span><span class="punct">(</span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">env0</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p><code class="inline">interpret</code> just glues all of the pieces together and provides a few primitives
for working with numbers and lists.
We also include a <code class="inline">debug</code> primitive for printing to the console, which relies on
<code class="inline">showValue</code>:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">showValue</span><span class="punct">(</span><span class="name">v</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">Array</span><span class="op">.</span><span class="name">isArray</span><span class="punct">(</span><span class="name">v</span><span class="punct">)</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="string">`(</span><span class="op">${</span><span class="name">v</span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">showValue</span><span class="punct">)</span><span class="op">.</span><span class="name">join</span><span class="punct">(</span><span class="string">&#x27; &#x27;</span><span class="punct">)</span><span class="op">}</span><span class="string">)`</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="keyword">typeof</span><span class="space"> </span><span class="name">v</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;object&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="string">&#x27;#&lt;closure&gt;&#x27;</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">v</span><span class="op">.</span><span class="name">toString</span><span class="punct">(</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Let&#x27;s give this baby a whirl:</p><pre><code><span class="name">interpret</span><span class="punct">(</span><span class="string">`
(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))

(define (map fn xs)
  (if (empty? xs)
      &#x27;()
      (cons (fn (head xs))
            (map fn (tail xs)))))

(define quux (map fact &#x27;(0 1 2 3 4 5)))

(debug quux)
`</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="comment">// =&gt; (1 1 2 6 24 120)</span></code></pre><h2 id="The-compiler,-finally">The compiler, finally</h2><p>Time for the payoff.
All that&#x27;s left is to write <code class="inline">compile</code>, which simply interpolates the provided
program into a template containing the interpreter code we just wrote.</p><p>Since we&#x27;re going to paste the interpreter source code inside a template string,
we need to be careful to escape all backticks (<code class="inline">`</code>); we also need to escape
dollar signs (<code class="inline">$</code>) and escape characters (<code class="inline">\</code>) as well.
This is easy enough to do manually, but we can also automate it with a little
script.</p><p>If the following is saved in a file named <em>quote.js</em>:</p><pre><code><span class="name">process</span><span class="op">.</span><span class="name">stdin</span><span class="line">
</span><span class="space">  </span><span class="op">.</span><span class="name">setEncoding</span><span class="punct">(</span><span class="string">&#x27;utf-8&#x27;</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="comment">// Replace backticks (`), dollar signs ($), and escape characters (\) with an</span><span class="line">
</span><span class="space">  </span><span class="comment">// escaped version, e.g. $ -&gt; \$.</span><span class="line">
</span><span class="space">  </span><span class="op">.</span><span class="name">map</span><span class="punct">(</span><span class="name">chunk</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="name">chunk</span><span class="op">.</span><span class="name">replace</span><span class="punct">(</span><span class="regex">/`|\$|\\/</span><span class="name">g</span><span class="punct">,</span><span class="space"> </span><span class="name">c</span><span class="space"> </span><span class="op">=</span><span class="op">&gt;</span><span class="space"> </span><span class="string">`\\</span><span class="op">${</span><span class="name">c</span><span class="op">}</span><span class="string">`</span><span class="punct">)</span><span class="punct">)</span><span class="line">
</span><span class="space">  </span><span class="op">.</span><span class="name">pipe</span><span class="punct">(</span><span class="name">process</span><span class="op">.</span><span class="name">stdout</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>and the interpreter source is saved in <em>pocket-scheme.js</em>, then</p><pre><code>$ node quote.js &lt; pocket-scheme.js &gt; quoted-interpreter.txt</code></pre><p>will save the quoted interpreter source in <em>quoted-interpreter.txt</em>.</p><p>In a new file (which I&#x27;m calling <em>not-a-compiler.js</em>), copy the quoted
interpreter source into the body of a function named <code class="inline">compile</code>, along with a
(quoted) invocation of the <code class="inline">interpret</code> function on the <code class="inline">source</code> of the program
to be <!-- -->“<!-- -->compiled<!-- -->”<!-- -->:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="name">interpreterSource</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="string">`
function lex(source) {
  const re = /\\(|\\)|\\[|\\]|&#x27;|[a-z+*\\-&lt;&gt;=!?]+|\\d+|#(t|f)/g;
  const parts = source.match(re);
...
`</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="string">`
</span><span class="op">${</span><span class="name">interpreterSource</span><span class="op">}</span><span class="string">

interpret(\`</span><span class="op">${</span><span class="name">source</span><span class="op">}</span><span class="string">\`);
`</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p><em>The full listing is available <a href="https://gist.github.com/wjlewis/a85a5b9a66875d82c1155a59474aee7d">here</a>.</em></p><p>Finally, to make our <!-- -->“<!-- -->compiler<!-- -->”<!-- --> a little more ergonomic, let&#x27;s read input
programs from <code class="inline">stdin</code> and write our compiled output to <code class="inline">stdout</code>:</p><pre><code><span class="keyword">const</span><span class="space"> </span><span class="name">fs</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">require</span><span class="punct">(</span><span class="string">&#x27;fs&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">const</span><span class="space"> </span><span class="name">source</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">fs</span><span class="op">.</span><span class="name">readFileSync</span><span class="punct">(</span><span class="number">0</span><span class="punct">,</span><span class="space"> </span><span class="string">&#x27;utf-8&#x27;</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="name">fs</span><span class="op">.</span><span class="name">writeFileSync</span><span class="punct">(</span><span class="number">1</span><span class="punct">,</span><span class="space"> </span><span class="name">compile</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>We can now compile Scheme files by executing</p><pre><code>$ node not-a-compiler.js &lt; my-program.scm</code></pre><p>or compile-and-execute via</p><pre><code>$ node not-a-compiler.js &lt; my-program.scm | node</code></pre><p>or compose on-the-fly with</p><pre><code>$ node not-a-compiler.js | node
(define (fib n)
  (cond [(= n 1) 1]
        [(= n 2) 1]
        [#t      (+ (fib (- n 1))
                    (fib (- n 2)))]))

(debug (fib 10))
Ctrl+D
55</code></pre><h2 id="Is-this-a-compiler?">Is this a compiler?</h2><p>Yes, according to the definition above, since</p><pre><code>$ node not-a-compiler.js &lt; my-prog.scm | node</code></pre><p>and</p><pre><code>$ scheme my-prog.scm</code></pre><p>produce the same result<a id="__footnote_ref_1" href="#__footnote_1" class="footnote-ref"><sup>1</sup></a>.</p><p>However, its output tells a different story.
We&#x27;d expect our compiler to transform the scheme program</p><pre><code><span class="punct">(</span><span class="name">debug</span><span class="space"> </span><span class="punct">(</span><span class="name">+</span><span class="space"> </span><span class="number">1</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span><span class="punct">)</span></code></pre><p>into something like</p><pre><code><span class="name">console</span><span class="op">.</span><span class="name">log</span><span class="punct">(</span><span class="number">1</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">2</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>instead it produces this monstrosity:</p><pre><code><span class="keyword">function</span><span class="space"> </span><span class="name">lex</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">parseProgram</span><span class="punct">(</span><span class="name">tokens</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="comment">// More definitions related to parsing...</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">evalProgram</span><span class="punct">(</span><span class="name">program</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">evalExpr</span><span class="punct">(</span><span class="name">expr</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="comment">// More definitions related to evaluation...</span><span class="line">

</span><span class="keyword">function</span><span class="space"> </span><span class="name">interpret</span><span class="punct">(</span><span class="name">source</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">

</span><span class="comment">// Interpreter support code...</span><span class="line">


</span><span class="name">interpret</span><span class="punct">(</span><span class="string">`(debug (+ 1 2))`</span><span class="punct">)</span><span class="punct">;</span></code></pre><p>Note in particular that our compiler hasn&#x27;t even touched the input we
supplied.</p><h3 id="An-analogy">An analogy</h3><p>Suppose Alice claims to be able to translate French commands into English.
However, each time you give her a command to translate, she just fills in this
template:</p><pre><code>Call my bilingual sister Marie at 555-1234.
Tell her you&#x27;re a friend of Alice and need a favor.
In particular, say that you need her to &quot;{{original-command}}&quot; as soon as
possible.</code></pre><p>Bob decides to test Alice with the command <em>apporte-moi un croissant</em>.</p><p>Alice <!-- -->“<!-- -->translates<!-- -->”<!-- --> this to:</p><pre><code>Call my bilingual sister Marie at 555-1234.
Tell her you&#x27;re a friend of Alice and need a favor.
In particular, say that you need her to &quot;apporte-moi un croissant&quot; as
soon as possible.</code></pre><p>Is this a valid translation?
It&#x27;s in English, and—more importantly—if Bob issues this command to someone who
only speaks English, he&#x27;ll end up with a croissant<a id="__footnote_ref_2" href="#__footnote_2" class="footnote-ref"><sup>2</sup></a>.</p><p>However, as in our compiler, <em>the original French phrase hasn&#x27;t been touched</em>.
Alice has simply bundled an <!-- -->“<!-- -->interpreter<!-- -->”<!-- --> (her sister) with the original French
phrase, along with enough plumbing to get the interpreter to execute the
command.
Our compiler is no different.</p><h2 id="So...is-this-a-compiler?">So...is this a compiler?</h2><p><a href="https://slatestarcodex.com/2014/11/21/the-categories-were-made-for-man-not-man-for-the-categories/">Sure, if you want it to be</a>.
What&#x27;s more interesting is what this means for our original definitions.
They&#x27;re short, sweet, and intellectually-pleasing.
We could even use them to draw some pretty diagrams.
But they admit pathological examples like the one we constructed here.
Practically-speaking this poses no problem: those definitions don&#x27;t really
matter when compiling or evaluating programs.
But it does raise an interesting question: can we devise a different pair of
definitions that excludes our compiler?
My gut tells me no, but I&#x27;ll think about this some more.</p><div id="__footnote_1" class="footnote"><a href="#__footnote_ref_1">1<!-- -->.</a><div class="footnote-content"><p>In this case, <code class="inline">node</code> is our interpreter function <code class="inline">i: JS -&gt; M</code>, and <code class="inline">node
      not-a-compiler.js</code> is our compiler <code class="inline">k: Scheme -&gt; JS</code>.</p></div></div><div id="__footnote_2" class="footnote"><a href="#__footnote_ref_2">2<!-- -->.</a><div class="footnote-content"><p>Marie will still need to infer or ask about some of the surrounding
            context (who does <!-- -->“<!-- -->moi<!-- -->”<!-- --> refer to?).
            Alice should really augment her template with an <!-- -->“<!-- -->initial
            environment<!-- -->”<!-- --> containing bindings for <!-- -->“<!-- -->global<!-- -->”<!-- --> identifiers, like</p><pre><code>moi -&gt; Bob
...</code></pre></div></div></main>
  </body>
</html>