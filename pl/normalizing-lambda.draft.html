<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="/notes/main.css" />
    
    <title>Normalizing lambda terms: 2 ways</title>
  </head>

  <body>
    <main><h1 id="Normalizing-lambda-terms:-2-ways">Normalizing lambda terms: 2 ways</h1><p>We&#x27;ll examine two methods for normalizing terms in the lambda calculus.</p><h2 id="Reduction-rules">Reduction rules</h2><p>Computation occurs where an abstraction is applied: a so-called <em>redex</em>.
We reduce a redex by substituting the operand term into the body of the
operator.
This rule is called <code class="inline code">beta</code>-reduction:</p><pre><code class="block code">-------------------- [beta]
(\.b) a -&gt; [0 -&gt; a]b</code></pre><p>The two remaining rules allow us to reduce non-redex applications in the hopes
of finding a redex.
The first says that operators can be reduced, and the second that operands can
be, as long as their operator is <!-- -->“<!-- -->stuck<!-- -->”<!-- --> (irreducible)<a id="__footnote_ref_1" href="#__footnote_1" class="footnote-ref"><sup>1</sup></a>:</p><pre><code class="block code">   a -&gt; a&#x27;
----------- [app1]
a t -&gt; a&#x27; t


   b -&gt; b&#x27;
----------- [app2]
s b -&gt; s b&#x27;</code></pre><p>It&#x27;s that simple, and that&#x27;s the beauty of the lambda calculus.</p><h2 id="Hunting-for-redexes">Hunting for redexes</h2><p>Our first approach involves descending into terms on the lookout for redexes.
Where a redex occurs, we apply the <code class="inline code">beta</code> rule; non-redex applications are
handled according to the remaining rules.
We implement this as a <code class="inline code">step</code> function which performs a single computation step
(reduction) if possible.
We&#x27;d also like <code class="inline code">step</code> to indicate whether a reduction was possible so we know
when a term is normalized.
So <code class="inline code">step</code> will produce a pair of values: the (possibly) stepped term, and a
boolean indicating whether any progress was made:</p><pre><code class="block code"><span class="comment">// Reduce a single redex if possible. Return an array with 2 elements:</span><span class="line">
</span><span class="comment">// 1. The (possibly) reduced term.</span><span class="line">
</span><span class="comment">// 2. `true` if the term was reduced, and `false` otherwise.</span><span class="line">
</span><span class="keyword">function</span><span class="space"> </span><span class="name">step</span><span class="punct">(</span><span class="name">term</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Addresses can&#x27;t be reduced, so we just return them, along with <code class="inline code">false</code> to
indicate that the term is stuck:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">step</span><span class="punct">(</span><span class="name">term</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;ADDR&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="name">term</span><span class="punct">,</span><span class="space"> </span><span class="keyword">false</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span></code></pre><p>We handle an abstraction by attempting to <code class="inline code">step</code> its body:</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;FN&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">progress</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">step</span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">body</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="punct">{</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">term</span><span class="punct">,</span><span class="space"> </span><span class="name">body</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="space"> </span><span class="name">progress</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>All of the action occurs in applications:</p><pre><code class="block code"><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;APP&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">rator</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;FN&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// We&#x27;re looking at a redex.</span><span class="line">
</span><span class="space">    </span><span class="comment">// Shift unbound operand addrs _up_ by one in anticipation of being</span><span class="line">
</span><span class="space">    </span><span class="comment">// shifted back _down_ after substitution.</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">arg</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">shift</span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">rand</span><span class="punct">,</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="comment">// Substitute arg for the bound addr in the operator&#x27;s body.</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">afterSubst</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">subst</span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">rator</span><span class="op">.</span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">arg</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">    </span><span class="comment">// Shift unbound addrs _down_ by 1 to account for the fact that the binder</span><span class="line">
</span><span class="space">    </span><span class="comment">// has been removed.</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="name">shift</span><span class="punct">(</span><span class="name">afterSubst</span><span class="punct">,</span><span class="space"> </span><span class="op">-</span><span class="number">1</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="keyword">true</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="comment">// ...</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>Conceptually, reducing a redex is simple: just substitute the operand for the
bound address wherever it occurs in the body of the operand abstraction.
The details are a little grittier:</p><ol><li><p>Since we&#x27;re going to strip a binder off the operand, we&#x27;ll need to shift all
  free addresses inside the operand&#x27;s body <em>down</em> by 1.</p></li><li><p><em>In anticipation of this</em>, we need to shift all free addresses inside the
  operand <em>up</em> by 1 (since these will be shifted <em>down</em> in the step just
  described).</p></li><li><p>We&#x27;ll perform (2) first.
  Before performing (1), we substitute the (shifted) operand into the body of
  the operand abstraction.
  Specifically, we replace all occurrences of the 0 address with the operand.</p></li></ol><p>The shift described in (1) is easier to justify.
If we&#x27;re reducing a redex within an abstraction, terms within the body of the
redex operand may refer to addresses bound <em>outside</em> the operand:</p><pre><code class="block code">\x -&gt; ... (\y -&gt; &lt;body&gt;) &lt;operand&gt; ...
 ^        ^^^^^^^^^^^^^^^^^^^^^^^^
 |        A redex living inside an abstraction.
 |        Addresses within &lt;body&gt; may refer to `x` -- +
 |                                                    |
 + ---------------------------------------------------+</code></pre><p>after reduction, these addresses will have one less binder between themselves
and their binder, so their addresses need to be decremented.</p><p>The shift described in (2) is a consequence of the fact that shift (1) occurs
<em>after</em> substituting the operand into the body<a id="__footnote_ref_2" href="#__footnote_2" class="footnote-ref"><sup>2</sup></a>.</p><p>All that remains are non-redex applications:</p><pre><code class="block code"><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="comment">// The operator isn&#x27;t an abstraction, but it might be reducible to an</span><span class="line">
</span><span class="space">  </span><span class="comment">// abstraction (which would reveal a redex on a subsequent step). Try to</span><span class="line">
</span><span class="space">  </span><span class="comment">// reduce it.</span><span class="line">
</span><span class="space">  </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">rator</span><span class="punct">,</span><span class="space"> </span><span class="name">progress</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">step</span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">rator</span><span class="punct">)</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">progress</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="punct">{</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">term</span><span class="punct">,</span><span class="space"> </span><span class="name">rator</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="space"> </span><span class="name">progress</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// If the operator was already reduced, try to reduce the operand.</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">rand</span><span class="punct">,</span><span class="space"> </span><span class="name">progress</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">step</span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">rand</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">[</span><span class="punct">{</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">term</span><span class="punct">,</span><span class="space"> </span><span class="name">rand</span><span class="space"> </span><span class="punct">}</span><span class="punct">,</span><span class="space"> </span><span class="name">progress</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span><span class="line">
</span><span class="comment">// ...</span></code></pre><p>What about <code class="inline code">shift</code> and <code class="inline code">subst</code>?</p><p>As described above, <code class="inline code">shift</code> shifts all <em>free</em> addresses by a given amount:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">shift</span><span class="punct">(</span><span class="name">term</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;ADDR&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Only shift the address if it&#x27;s free (greater than or equal to the current</span><span class="line">
</span><span class="space">    </span><span class="comment">// number of binders we&#x27;ve encountered).</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">addr</span><span class="space"> </span><span class="op">&gt;</span><span class="op">=</span><span class="space"> </span><span class="name">binderCount</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">        </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">term</span><span class="punct">,</span><span class="line">
</span><span class="space">        </span><span class="name">addr</span><span class="op">:</span><span class="space"> </span><span class="name">term</span><span class="op">.</span><span class="name">addr</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="name">n</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">term</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;FN&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="comment">// Increment the `binderCount` since we&#x27;ve encountered another binder.</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">term</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">body</span><span class="op">:</span><span class="space"> </span><span class="name">shift</span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;APP&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">term</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rator</span><span class="op">:</span><span class="space"> </span><span class="name">shift</span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">rator</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rand</span><span class="op">:</span><span class="space"> </span><span class="name">shift</span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">rand</span><span class="punct">,</span><span class="space"> </span><span class="name">n</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>and <code class="inline code">subst</code> substitutes a term for the <code class="inline code">0</code> address inside another term:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">subst</span><span class="punct">(</span><span class="name">host</span><span class="punct">,</span><span class="space"> </span><span class="name">sub</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">host</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;ADDR&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">host</span><span class="op">.</span><span class="name">addr</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="name">binderCount</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">shift</span><span class="punct">(</span><span class="name">sub</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">host</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">host</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;FN&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">host</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">body</span><span class="op">:</span><span class="space"> </span><span class="name">subst</span><span class="punct">(</span><span class="name">host</span><span class="op">.</span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="name">sub</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">host</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;APP&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">host</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rator</span><span class="op">:</span><span class="space"> </span><span class="name">subst</span><span class="punct">(</span><span class="name">host</span><span class="op">.</span><span class="name">rator</span><span class="punct">,</span><span class="space"> </span><span class="name">sub</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rand</span><span class="op">:</span><span class="space"> </span><span class="name">subst</span><span class="punct">(</span><span class="name">host</span><span class="op">.</span><span class="name">rand</span><span class="punct">,</span><span class="space"> </span><span class="name">sub</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Finally, we can define <code class="inline code">normalize</code> in terms of <code class="inline code">step</code>:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">normalize</span><span class="punct">(</span><span class="name">term</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">while</span><span class="space"> </span><span class="punct">(</span><span class="keyword">true</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="punct">[</span><span class="name">stepped</span><span class="punct">,</span><span class="space"> </span><span class="name">madeProgress</span><span class="punct">]</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">step</span><span class="punct">(</span><span class="name">term</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="name">term</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">stepped</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="op">!</span><span class="name">madeProgress</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">term</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Let&#x27;s try a few examples.
A term representing 4 factorial:</p><pre><code class="block code">(\self -&gt; \n -&gt; (n (\p -&gt; \t f -&gt; f) (\t f -&gt; t))
                  (\s z -&gt; s z)
                  ((\m n -&gt; m (\p -&gt; \s z -&gt; p s (n s z)) (\s z -&gt; z))
                   n
                   ((self self)
                    ((\n -&gt; 
                      (n
                       (\p -&gt; (\f s -&gt; \elim -&gt; elim f s)
                               (\s z -&gt; s ((p \f s -&gt; f) s z))
                               (p \f s -&gt; f))
                       ((\f s -&gt; \elim -&gt; elim f s)
                        (\s z -&gt; z)
                        (\s z -&gt; z)))
                      (\f s -&gt; s))
                     n))))
(\self -&gt; \n -&gt; (n (\p -&gt; \t f -&gt; f) (\t f -&gt; t))
                  (\s z -&gt; s z)
                  ((\m n -&gt; m (\p -&gt; \s z -&gt; p s (n s z)) (\s z -&gt; z))
                   n
                   ((self self)
                    ((\n -&gt; 
                      (n
                       (\p -&gt; (\f s -&gt; \elim -&gt; elim f s)
                               (\s z -&gt; s ((p \f s -&gt; f) s z))
                               (p \f s -&gt; f))
                       ((\f s -&gt; \elim -&gt; elim f s)
                        (\s z -&gt; z)
                        (\s z -&gt; z)))
                      (\f s -&gt; s))
                     n))))
(\s z -&gt; s (s (s (s z))))</code></pre><p>is normalized to 24:</p><pre><code class="block code">\s z -&gt; s ( ... z )
            ^^^ 23 more applications of `s`</code></pre><p>We can also verify that we&#x27;re using a normal order strategy by normalizing this
term:</p><pre><code class="block code">(\x y -&gt; y) ((\x -&gt; x x) \x -&gt; x x) (\x -&gt; x)
  ^         ^^^^^^^^^^^^^^^^^^^^^^^
  |                   |
  + ----------------- +

If operands are reduced first, this will loop forever.
In the normal order strategy the first operand is discarded and no
looping occurs.</code></pre><p>to</p><pre><code class="block code">\x -&gt; x</code></pre><p>While naive, this first approach offers some nice benefits:</p><ul><li><p>It&#x27;s simple and therefore easy to verify</p></li><li><p>It allows us to step terms, which is useful when learning or debugging.</p></li></ul><p>Unfortunately, it&#x27;s dreadfully slow (try normalizing 7 factorial).
I suspect this is because</p><ul><li><p>It allocates all over the place (when descending into terms, when shifting,
 when substituting)</p></li><li><p>It throws away information after each <code class="inline code">step</code>, requiring it to
 re-descend—possibly very deeply—into a term over and over.</p></li></ul><p>The next approach trades simplicity for speed.</p><h2 id="Normalization-by-evaluation">Normalization by evaluation</h2><p><strong>WIP WIP WIP</strong></p><p>In the <!-- -->“<!-- -->hunting<!-- -->”<!-- --> approach just described, we&#x27;ve thought about normal forms as
terms in which no reductions are possible.
The reductions rules guided this approach by showing us where reductions can be
made, and how to perform them.</p><p>Alternatively, we can think of the reduction rules as defining an equivalence
relation between terms, and normal forms as special <!-- -->“<!-- -->canonical representatives<!-- -->”<!-- -->
of each equivalence class.
The task of normalization then is to find the representative for a given term.</p><p><em>Normalization by evaluation</em> finds the normal form for a term by (1)
<em>evaluating</em> the term into a <!-- -->“<!-- -->value<!-- -->”<!-- -->, and then (2) <em>reifying</em> the value into a
normal form.
So we need a type of values, a function <code class="inline code">eval : Term -&gt; Value</code>, and a function
<code class="inline code">reify : Value -&gt; NormalTerm</code><a id="__footnote_ref_3" href="#__footnote_3" class="footnote-ref"><sup>3</sup></a>.</p><p>Normalization is then just a matter of composing <code class="inline code">reify</code> and <code class="inline code">eval</code>.
This works because <code class="inline code">reify</code> can <em>only</em> produce normal forms.</p><p>Enough chit-chat.
Here&#x27;s <code class="inline code">eval</code>:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">eval</span><span class="punct">(</span><span class="name">term</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">[</span><span class="punct">]</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;ADDR&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">env</span><span class="punct">[</span><span class="name">term</span><span class="op">.</span><span class="name">addr</span><span class="punct">]</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;FN&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;CLOS&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">param</span><span class="op">:</span><span class="space"> </span><span class="name">term</span><span class="op">.</span><span class="name">param</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">body</span><span class="op">:</span><span class="space"> </span><span class="name">term</span><span class="op">.</span><span class="name">body</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">env</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;APP&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">op</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">eval</span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">rator</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">arg</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">Thunk</span><span class="punct">(</span><span class="name">term</span><span class="op">.</span><span class="name">rand</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">apply</span><span class="punct">(</span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">arg</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Our value type consists of <em>closures</em>, <em>thunks</em>, and two more variants that
we&#x27;ll see shortly.
To evaluate an address, we look up its value in an environment; abstractions
evaluate to closures, and applications dispatch to <code class="inline code">apply</code>:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">apply</span><span class="punct">(</span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">arg</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">op</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;CLOS&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">eval</span><span class="punct">(</span><span class="name">op</span><span class="op">.</span><span class="name">body</span><span class="punct">,</span><span class="space"> </span><span class="punct">[</span><span class="name">arg</span><span class="punct">,</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="name">op</span><span class="op">.</span><span class="name">env</span><span class="punct">]</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">op</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;THUNK&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">apply</span><span class="punct">(</span><span class="name">op</span><span class="op">.</span><span class="name">thaw</span><span class="punct">(</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">arg</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">op</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;STUCK_ADDR&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;STUCK_APP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">arg</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">op</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;STUCK_APP&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;STUCK_APP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">op</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">arg</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Here we see the two remaining value variants: <!-- -->“<!-- -->stuck addresses<!-- -->”<!-- --> and <!-- -->“<!-- -->stuck
applications<!-- -->”<!-- -->.
Stuck addresses are created when reifying closures.
A thunk defers evaluation until <code class="inline code">thaw</code> is called, and then remembers its value:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">Thunk</span><span class="punct">(</span><span class="name">term</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">let</span><span class="space"> </span><span class="name">value</span><span class="punct">;</span><span class="line">

</span><span class="space">  </span><span class="keyword">function</span><span class="space"> </span><span class="name">thaw</span><span class="punct">(</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">value</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="keyword">return</span><span class="space"> </span><span class="name">value</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="line">
</span><span class="space">    </span><span class="name">value</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">eval</span><span class="punct">(</span><span class="name">term</span><span class="punct">,</span><span class="space"> </span><span class="name">env</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">value</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">

</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;THUNK&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">thaw</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Reification transforms a value back into a term:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">reify</span><span class="punct">(</span><span class="name">value</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="number">0</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">value</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;CLOS&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">arg</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="punct">{</span><span class="space"> </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;STUCK_ADDR&#x27;</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="space"> </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">body</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">reify</span><span class="punct">(</span><span class="name">apply</span><span class="punct">(</span><span class="name">value</span><span class="punct">,</span><span class="space"> </span><span class="name">arg</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="space"> </span><span class="op">+</span><span class="space"> </span><span class="number">1</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;FN&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">param</span><span class="op">:</span><span class="space"> </span><span class="name">value</span><span class="op">.</span><span class="name">param</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">body</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">value</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;THUNK&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="name">reify</span><span class="punct">(</span><span class="name">value</span><span class="op">.</span><span class="name">thaw</span><span class="punct">(</span><span class="punct">)</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">value</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;STUCK_ADDR&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">const</span><span class="space"> </span><span class="name">addr</span><span class="space"> </span><span class="op">=</span><span class="space"> </span><span class="name">binderCount</span><span class="space"> </span><span class="op">-</span><span class="space"> </span><span class="name">value</span><span class="op">.</span><span class="name">binderCount</span><span class="space"> </span><span class="op">-</span><span class="space"> </span><span class="number">1</span><span class="punct">;</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;ADDR&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">addr</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="space"> </span><span class="keyword">else</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="punct">(</span><span class="name">value</span><span class="op">.</span><span class="name">type</span><span class="space"> </span><span class="op">=</span><span class="op">=</span><span class="op">=</span><span class="space"> </span><span class="string">&#x27;STUCK_APP&#x27;</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">    </span><span class="keyword">return</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">      </span><span class="name">type</span><span class="op">:</span><span class="space"> </span><span class="string">&#x27;APP&#x27;</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rator</span><span class="op">:</span><span class="space"> </span><span class="name">reify</span><span class="punct">(</span><span class="name">value</span><span class="op">.</span><span class="name">op</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">      </span><span class="name">rand</span><span class="op">:</span><span class="space"> </span><span class="name">reify</span><span class="punct">(</span><span class="name">value</span><span class="op">.</span><span class="name">arg</span><span class="punct">,</span><span class="space"> </span><span class="name">binderCount</span><span class="punct">)</span><span class="punct">,</span><span class="line">
</span><span class="space">    </span><span class="punct">}</span><span class="punct">;</span><span class="line">
</span><span class="space">  </span><span class="punct">}</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Unsurprisingly, closures present the most interesting case here.
We reify a closure by applying it to a <!-- -->“<!-- -->fake<!-- -->”<!-- --> value, reifying the result, and
slapping a binder on top.</p><p>With <code class="inline code">eval</code> and <code class="inline code">reify</code> defined, normalization is straightforward:</p><pre><code class="block code"><span class="keyword">function</span><span class="space"> </span><span class="name">normalize</span><span class="punct">(</span><span class="name">term</span><span class="punct">)</span><span class="space"> </span><span class="punct">{</span><span class="line">
</span><span class="space">  </span><span class="keyword">return</span><span class="space"> </span><span class="name">reify</span><span class="punct">(</span><span class="name">eval</span><span class="punct">(</span><span class="name">term</span><span class="punct">)</span><span class="punct">)</span><span class="punct">;</span><span class="line">
</span><span class="punct">}</span></code></pre><p>Normalization by evaluation is <em>much</em> faster than hunting for redexes.
For example, it normalizes 6 factorial instantaneously on my machine.
Unfortunately it&#x27;s not altogether superior:</p><ul><li><p>Stack overflows are now a concern, even when they shouldn&#x27;t be (depending on
 our implementation language).
 Attempting to normalize <code class="inline code">(\x -&gt; x x) \x -&gt; x x</code> shouldn&#x27;t result in a stack
 overflow, but it does.</p></li><li><p>It&#x27;s not clear how to <!-- -->“<!-- -->step<!-- -->”<!-- --> terms.</p></li></ul><div id="__footnote_1" class="footnote"><a href="#__footnote_ref_1">1<!-- -->.</a><div class="footnote-content"><p>These rules describe the <!-- -->“<!-- -->normal order<!-- -->”<!-- --> reduction strategy.
  The most common alternative strategy is <!-- -->“<!-- -->applicative order<!-- -->”<!-- -->, which requires
  that operands be normalized before redexes are reduced.</p></div></div><div id="__footnote_2" class="footnote"><a href="#__footnote_ref_2">2<!-- -->.</a><div class="footnote-content"><p>Why can&#x27;t we first perform shift (1) and then substitute the
  operand for address <code class="inline code">-1</code> within the shifted body, skipping the anticipatory
  shift (2)?
  I&#x27;m not sure.
  This <em>feels</em> like it should work, but I gave this a quick shot and it didn&#x27;t.
  That said, I haven&#x27;t spent too much time checking for silly errors I might
  have made.</p></div></div><div id="__footnote_3" class="footnote"><a href="#__footnote_ref_3">3<!-- -->.</a><div class="footnote-content"><p>I&#x27;m not entirely sure about my definition of <code class="inline code">reify</code> here.
  requiring that it transform values into a type whose <em>only</em> inhabitants are
  normal terms feels correct to me, but I haven&#x27;t seen this anywhere else.
  Ideally, we&#x27;d prove that <code class="inline code">NormalTerm</code> can be <em>embedded</em> in <code class="inline code">Term</code> in a way
  that respects evaluation:</p><pre><code class="block code"><span class="op">-</span><span class="op">-</span><span class="space"> </span><span class="name">Normal</span><span class="space"> </span><span class="name">forms</span><span class="space"> </span><span class="op">_</span><span class="name">are_</span><span class="space"> </span><span class="name">terms</span><span class="op">.</span><span class="line">
</span><span class="name">embed</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="name">NormalTerm</span><span class="space"> </span><span class="op">-</span><span class="op">&gt;</span><span class="space"> </span><span class="name">Term</span><span class="line">
</span><span class="name">embed</span><span class="space"> </span><span class="punct">=</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span><span class="line">

</span><span class="op">-</span><span class="op">-</span><span class="space"> </span><span class="name">There</span><span class="space"> </span><span class="name">are</span><span class="space"> </span><span class="name">many</span><span class="space"> </span><span class="name">ways</span><span class="space"> </span><span class="name">to</span><span class="space"> </span><span class="name">write</span><span class="space"> </span><span class="unknown">`</span><span class="name">embed</span><span class="unknown">`</span><span class="space"> </span><span class="punct">(</span><span class="name">e</span><span class="op">.</span><span class="name">g</span><span class="op">.</span><span class="space"> </span><span class="name">map</span><span class="space"> </span><span class="name">every</span><span class="space"> </span><span class="name">normal</span><span class="space"> </span><span class="name">term</span><span class="space"> </span><span class="name">to</span><span class="space"> </span><span class="name">the</span><span class="line">
</span><span class="op">-</span><span class="op">-</span><span class="space"> </span><span class="name">identity</span><span class="space"> </span><span class="name">term</span><span class="punct">)</span><span class="op">.</span><span class="space"> </span><span class="name">An</span><span class="space"> </span><span class="name">embedding</span><span class="space"> </span><span class="unknown">&quot;</span><span class="name">does</span><span class="space"> </span><span class="name">what</span><span class="space"> </span><span class="name">we</span><span class="space"> </span><span class="name">want</span><span class="unknown">&quot;</span><span class="space"> </span><span class="keyword">if</span><span class="space"> </span><span class="name">it</span><span class="space"> </span><span class="name">respects</span><span class="space"> </span><span class="name">evaluation</span><span class="op">:</span><span class="line">
</span><span class="name">embed_respects_eval</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="punct">(</span><span class="name">n</span><span class="space"> </span><span class="op">:</span><span class="space"> </span><span class="name">NormalTerm</span><span class="punct">)</span><span class="space"> </span><span class="op">-</span><span class="op">&gt;</span><span class="space"> </span><span class="name">eval</span><span class="space"> </span><span class="punct">(</span><span class="name">embed</span><span class="space"> </span><span class="name">n</span><span class="punct">)</span><span class="space"> </span><span class="unknown">≡</span><span class="space"> </span><span class="name">n</span><span class="line">
</span><span class="name">embed_respects_eval</span><span class="space"> </span><span class="punct">=</span><span class="space"> </span><span class="op">.</span><span class="op">.</span><span class="op">.</span></code></pre></div></div></main>
  
    <footer>
      <span>Created: 8/14/2023</span>
      <span>Last updated: 8/14/2023</span>
    </footer>
  </body>
</html>